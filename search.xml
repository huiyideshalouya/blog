<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BPMN相关知识</title>
    <url>/2024/05/29/BPMN%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="BPMN相关知识"><a href="#BPMN相关知识" class="headerlink" title="BPMN相关知识"></a>BPMN相关知识</h2><p>1.基础概念</p>
<p><strong>流程（Process）</strong>：BPMN 所描述的业务运行的过程。</p>
<p><strong>活动（Activity）</strong>：流程中的具体任务或操作。</p>
<p><strong>事件（Event）</strong>：流程中引发或响应的特定点，如开始事件、结束事件等。</p>
<p><strong>网关（Gateway）</strong>：用于控制流程的分支和合并。</p>
<p><strong>顺序流（Sequence Flow）</strong>：指示活动的执行顺序。</p>
<p><strong>泳道（Swimlane）</strong>：通常分为池（Pool）和道（Lane），用于划分不同的组织或角色在流程中的责任区域。</p>
<p><strong>数据对象（Data Object）</strong>：与流程相关的数据。</p>
<p><strong>消息流（Message Flow）</strong>：用于表示不同池之间的通信。</p>
]]></content>
  </entry>
  <entry>
    <title>JMM模型</title>
    <url>/2024/05/06/JMM%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h2><h3 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h3><p>Volitale</p>
<ul>
<li>CPU缓存问题</li>
<li>MESI协议<ul>
<li>缓存锁</li>
<li>总线锁</li>
<li>基于LOCK这么一个汇编指令</li>
</ul>
</li>
<li>可见性,有序性保证</li>
</ul>
<h3 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2.有序性"></a>2.有序性</h3><ul>
<li><p>JVM如何实现跨平台下的线程安全</p>
<ul>
<li><p>JMM模型,定义多线程场景下数据操作逻辑,根据不同平台生成对应的指令</p>
<ul>
<li>通过区分本地内存和主内存</li>
<li>线程操作数据都会先从主内存拷贝,自己的本地内存完成修改后,再将其同步到主内存</li>
<li>每个线程都存有一个数据副本到自己的本地内存</li>
</ul>
</li>
<li><p>CPU内存屏障指令(针对不同系统,架构有不同实现)</p>
<p>屏障类型</p>
<ul>
<li><p>LoadLoad  读1操作不可优先于读2操作</p>
</li>
<li><p>StoreStore 写1操作不可优先于写2操作</p>
</li>
<li><p>LoadStore 读操作优先于写操作</p>
</li>
<li><p>StoreLoad 写操作优先于读操作</p>
</li>
<li><p>基于上述方法接口,实现出不同平台下的逻辑</p>
</li>
<li><blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/JMM/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%B1%BB%E5%9E%8B.png"
                      alt="内存屏障类型"
                ></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>产生原因</p>
<ul>
<li>CPU高速缓存<ul>
<li>MESI(同步给其它cpu),解决可见性,保证缓存一致性</li>
</ul>
</li>
<li>指令重排序<ul>
<li>内存屏障(避免指令执行顺序被优化),解决有序性</li>
</ul>
</li>
</ul>
</li>
<li><p>volitale重排序规则</p>
<p>不管是普通变量还是volitale变量,对于在volitale变量的读操作之间进行写操作是不允许重排序的</p>
<ul>
<li><blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/JMM/Volatile%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99.png"
                      alt="Volatile重排序规则"
                ></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>如何解决上述问题</p>
<ul>
<li><p>synchroized</p>
</li>
<li><p>volitale</p>
</li>
<li><p>final(内存屏障指令),只能在构造方法之内完成初始化,而在构造方法中初始化的指令,不允许重排序到构造</p>
<p>方法之外,这里使用了内存屏障指令</p>
</li>
</ul>
<p><strong>不是所有的程序指令都会存在可见性或指令重排序(as-if-serial )问题</strong></p>
<p>Happens-Before(明确哪些场景下不会出现问题)操作的有序性,操作性依赖</p>
<ul>
<li>程序顺序型规则 (as-if-serial),单线程执行不影响</li>
<li>传递性规则</li>
<li>volatile变量规则</li>
<li>监视器锁规则</li>
<li>start规则</li>
<li>join规则<ul>
<li>哪个线程调用就阻塞哪个线程,必须等待join线程完成,适用于按照指定顺序执行的情况</li>
</ul>
</li>
<li>单线程环境下不改变程序运行的结果,以及不存在依赖关系这些场景允许重排序</li>
<li>本质上是描述可见性的规则(有序性导致的可见性问题)</li>
</ul>
<p>典型案例</p>
<p>DCL(Double Check Lock)</p>
<ul>
<li><p>在new对象的过程中,在jvm里需要三个步骤,开辟空间—&gt;对象初始化—&gt;返回对象引用</p>
</li>
<li><p>而在多线程场景下,如果不对这个对象使用Volatile修饰(lock指令加锁),就有可能出现指令</p>
<p>重排序的问题</p>
</li>
</ul>
<h3 id="3-Lock设计预想"><a href="#3-Lock设计预想" class="headerlink" title="3.Lock设计预想"></a>3.Lock设计预想</h3><p>重入锁指的是再获取同一把锁时,无需重复获取,记录持有次数即可</p>
<p>特点</p>
<ul>
<li>可重入</li>
<li>支持公平,非公平锁</li>
<li>支持打断</li>
<li>支持多条件变量</li>
<li>支持手动释放,需要在finally使用完后进行兜底释放</li>
</ul>
<p>实现原理</p>
<ul>
<li><p>如何支持线程互斥特性,只有拿到锁后才能执行lock方法里的代码,否则只能排队等待</p>
<ul>
<li>涉及到锁的抢占,需要一个标记是否有线程获取到锁,全局变量(0,1)</li>
<li>抢到会怎么样,无需任何操作</li>
<li>没抢到会怎么样<ul>
<li>需要等待 (等待线程进入阻塞状态,释放CPU资源,阻塞—&gt;CPU资源释放)<ul>
<li>如何让线程等待<ul>
<li>wait&#x2F;notify线程通信机制,但无法指定唤醒某个线程</li>
<li>LockSupport.park&#x2F;unpark (阻塞一个指定线程,唤醒一个指定线程)</li>
<li>Condition</li>
</ul>
</li>
</ul>
</li>
<li>需要排队 (运行有n个线程被阻塞,被存储之前的线程都处于活跃状态)<ul>
<li>通过一个数据结构,把需要等待线程存储起来</li>
</ul>
</li>
</ul>
</li>
<li>使用完如何释放<ul>
<li>LockSupport.park—-&gt;唤醒队列中指定线程</li>
</ul>
</li>
<li>锁抢占的公平性(是否允许插队)<ul>
<li>公平</li>
<li>非公平</li>
</ul>
</li>
</ul>
</li>
<li><p>获取不到锁会阻塞,直到获取到后才会继续执行</p>
</li>
<li><p>抢占锁—&gt;抢占到后修改状态—&gt;执行任务—&gt;执行完成—&gt;修改state—&gt;释放锁资源—&gt;唤醒队列中等待线程</p>
<p>​           —&gt;没抢占到进入阻塞队列—&gt;修改线程状态—&gt;释放CPU执行资源—&gt;等待唤醒—&gt;再次抢占</p>
</li>
</ul>
<p>具体实现</p>
<ul>
<li><p>reentrantLock本质上就是AQS+LOCK组成</p>
</li>
<li><p>内部结构</p>
<ul>
<li><p>锁持有线程(记录当前持有线程对象)</p>
</li>
<li><p>共享变量(初始0,持有为1,重入则可能大于0(重入次数))</p>
<ul>
<li>volatile修饰保证可见性</li>
<li>cas()方法保证原子性,尝试修改</li>
</ul>
</li>
<li><p>等待队列</p>
<ul>
<li><p>双向链表存储,Head节点指向第一个节点,tail指向最后一个节点,将线程对象封装c</p>
<p>成Node对象</p>
</li>
<li><p>自旋操作,尝试抢占资源,未获取成功则进入阻塞状态,避免浪费cpu资源</p>
<p>调用LockSupport.parlk(this),阻塞自己</p>
</li>
<li><p>线程使用完锁后,唤醒等待队列的线程,从Head开始唤醒,唤醒它的下一个节点</p>
<p>.再调用LockSupport.unpark(ThreadB),唤醒指定线程</p>
</li>
<li><p>非公平允许插队,不管队列中有没有线程,公平则不允许,必须加入队列,排队等待</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流程图</p>
<ul>
<li><blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/JMM/ReenTrantLock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"
                      alt="ReenTrantLock实现原理"
                ></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="4-LOCK的具体实现"><a href="#4-LOCK的具体实现" class="headerlink" title="4.LOCK的具体实现"></a>4.LOCK的具体实现</h3><ul>
<li><p>具体实现</p>
<blockquote>
<p>ReentrantLock</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/JMM/Java%E9%94%81%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.png"
                      alt="Java锁实现关系"
                ></p>
<ul>
<li>reentrant实现Lock(锁机制)和持有Sync(同步队列)</li>
<li>AQS负责实现同步队列的基本逻辑,如唤醒,加入队列等方法</li>
<li>Sync继承AQS抽象类</li>
<li>在Sync的基础上实现公平和非公平</li>
</ul>
</blockquote>
</li>
</ul>
<p>节点状态</p>
<ul>
<li>signal  需要被唤醒的一个节点</li>
<li>cancelled 一个取消的节点</li>
<li>condition </li>
<li>propgate</li>
<li>0 默认值</li>
</ul>
<p>公平锁和非公平锁</p>
<ul>
<li><p>是否阻塞线程</p>
</li>
<li><p>是否公平</p>
</li>
<li><p>抢占时机</p>
</li>
<li><p>抢占失败</p>
<ul>
<li><p>进入队列</p>
</li>
<li><p>自旋(重试获取锁),等待(重试达到上限后将节点状态变为阻塞)</p>
</li>
<li><p>阻塞重试达到上限的线程</p>
</li>
<li><p>等待唤醒</p>
</li>
<li><p>当前线程抢占失败—&gt;进入同步队列—&gt;包装成Node节点.赋waitStatus状态为0—&gt;自旋,判断前置节点</p>
<p>—&gt;尝试获取锁,重试上限—&gt;放弃获取,进入阻塞状态</p>
</li>
</ul>
</li>
<li><p>唤醒时机</p>
</li>
<li><p>锁释放</p>
</li>
</ul>
<h3 id="5-遵守原则"><a href="#5-遵守原则" class="headerlink" title="5.遵守原则"></a>5.遵守原则</h3><ol>
<li><strong>缓存一致性模型</strong>：保证不同处理器核心或线程的缓存数据同步。</li>
<li><strong>重排序规则</strong>：指令执行顺序可能会被重新排列，但要遵循特定的约束以保证正确性。</li>
<li><strong>Happen-Before 关系</strong>：明确操作之间的先后顺序，确保多线程程序的正确执行。</li>
<li><strong>同步机制规则</strong>：包括锁、同步方法和同步块等的使用规则。</li>
<li><strong>内存屏障规则</strong>：用于控制指令重排序和确保内存操作的顺序。</li>
</ol>
<ul>
<li>按照这些规则做,就会降低线程安全产生的风险</li>
</ul>
<p>JMM</p>
<p>JUC</p>
<p>ThreadExectors</p>
<p>阻塞队列</p>
<p>可见性—&gt;缓存一致性问题—&gt;MESI和总线锁</p>
<p>有序性—&gt;CPU指令重排序—&gt;Volatile</p>
<p>happens-before</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/07/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Neetty高性能网络通讯框架</title>
    <url>/2024/07/07/Netty%20%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="Netty-高性能网络通讯框架"><a href="#Netty-高性能网络通讯框架" class="headerlink" title="Netty 高性能网络通讯框架"></a>Netty 高性能网络通讯框架</h2><p>关联网络I&#x2F;O模型,I&#x2F;O多路复用机制,Reactor模型(分治思想)</p>
<p>前置知识<br>阻塞队列是一种特殊的队列，当队列为空时进行获取操作会阻塞线程，直到队列中有元素；当队列已满时进行添加操作会阻塞线程，直到队列有空间。很多情况下，线程池使用的任务队列就是阻塞队列，比如常见的有<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>等，它们能很好地配合线程池的运行机制，实现任务的暂存和调度。但也存在一些非阻塞队列被用作任务队列的情况。</p>
<p>它其实是对NIO的一种封装后的高性能通讯框架</p>
<h3 id="1-常用api"><a href="#1-常用api" class="headerlink" title="1.常用api"></a>1.常用api</h3><ul>
<li>EventLoop</li>
<li>TransSportChannel</li>
<li>ChannelPipline</li>
<li>ChannelHandler</li>
<li>ByteBuffer</li>
<li>Bootstrap</li>
<li>ServerBootStrap</li>
</ul>
<h3 id="2-Netty工作机制"><a href="#2-Netty工作机制" class="headerlink" title="2.Netty工作机制"></a>2.Netty工作机制</h3><ul>
<li><p>核心流程</p>
</li>
<li><p>层次划分</p>
<ul>
<li><p>网络通讯层</p>
</li>
<li><p>事件调度器</p>
<ul>
<li><p>事件注册&#x2F;提交</p>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/Netty/%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C%E6%88%96%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.png"
                      alt="事件注册或提交流程"
                ></p>
</blockquote>
</li>
<li><p>整体流程</p>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/Netty/%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png"
                      alt="事件调度流程"
                ></p>
</blockquote>
</li>
</ul>
</li>
<li><p>服务编排层</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-支持的I-O模式"><a href="#3-支持的I-O模式" class="headerlink" title="3.支持的I&#x2F;O模式"></a>3.支持的I&#x2F;O模式</h3><ul>
<li>NIO,主要支持的模型,同步非阻塞,支持Reactor模式,如单线程,多线程,主从多线程</li>
<li>OIO,同步阻塞</li>
</ul>
<h3 id="4-请求处理"><a href="#4-请求处理" class="headerlink" title="4.请求处理"></a>4.请求处理</h3><p>Tomcat也是对请求参数的封装,然后再传递到对应的展现层,否则Http请求无法直接使用<br>需要一个转换的过程</p>
<p>Netty则使用了Handler的方式完成参数的处理</p>
<h3 id="5-事件轮询"><a href="#5-事件轮询" class="headerlink" title="5.事件轮询"></a>5.事件轮询</h3><p>轮询注册器找到需要执行的I&#x2F;O事件,这个操作是阻塞的,会让线程阻塞一段时间,等待一下<br>超时</p>
<h3 id="6-服务编排"><a href="#6-服务编排" class="headerlink" title="6.服务编排"></a>6.服务编排</h3><p>每个channel 具有一个channelPipline,所以这个管道是线程安全的,不会出现数据安全问题</p>
<p>存储的结构为双向链表,对应的channelHandler存储在这里</p>
<h3 id="7-核心角色"><a href="#7-核心角色" class="headerlink" title="7.核心角色"></a>7.核心角色</h3><p>事件循环组</p>
<p>工作时间循环</p>
<p>注册器</p>
<p>处理器</p>
<p>处理器管道</p>
<p>通道</p>
<p>通道管道</p>
<h3 id="8-注册"><a href="#8-注册" class="headerlink" title="8.注册"></a>8.注册</h3><p>serverSocket开启端口监听,多个客户端连接该端口,server在监听到连接请求后,<br>为其分配channel并将其注册到不同的Selector上,交给不同线程处理</p>
<h3 id="9-实现"><a href="#9-实现" class="headerlink" title="9.实现"></a>9.实现</h3><ul>
<li>RPC<ul>
<li>Dubbo</li>
<li>gRpc</li>
</ul>
</li>
<li>MQ<ul>
<li>Rocket</li>
</ul>
</li>
<li>WEB<ul>
<li>Spring WebFlux</li>
</ul>
</li>
<li>DB<ul>
<li>ElasticSearch</li>
</ul>
</li>
</ul>
<h3 id="10-ByteBuf"><a href="#10-ByteBuf" class="headerlink" title="10.ByteBuf"></a>10.ByteBuf</h3><p>它是NIO中的Bytebuffer的具体实现,用于网络通讯中的数据缓冲,<br>但不同的点是它使用了池化技术</p>
<h3 id="11-拆包和粘包"><a href="#11-拆包和粘包" class="headerlink" title="11.拆包和粘包"></a>11.拆包和粘包</h3><p>定义消息传输协议,在这里面就会涉及到数据的粘包和拆包,通俗的说<br>就是数据包如何装起来,倒出来</p>
<p>数据结构</p>
<ul>
<li>销毁</li>
<li>读取</li>
<li>写入</li>
<li>扩容</li>
<li>当前容量</li>
<li>最大容量</li>
</ul>
<p>回退</p>
<ul>
<li>为什么要回退</li>
<li>对于已经读取过的数据,想要再次读取,就可以使用对应方法再次读取</li>
<li>分别为读回退和写回退</li>
</ul>
<p>零拷贝(浅拷贝,修改引用内容,而不是深拷贝)</p>
<ul>
<li>如何提高内存复制性能,这里和网络拷贝的零拷贝不一样</li>
<li>如何实现,对元素数据切片,再修改指定索引的元素,意思是直接修改的内存数据吗<br>而不是先拷贝,再修改</li>
<li>逻辑合并的原理是其内部维护了一个引用列表?然后对对应的指针完成引用数据数据修改,而不是拷贝出来一个新的</li>
<li>拆分场景</li>
<li>合并场景<ul>
<li>深拷贝</li>
<li>浅拷贝</li>
<li>Unpooled</li>
</ul>
</li>
</ul>
<p>拆包&#x2F;粘包</p>
<p>拆分原因,TCP的传输是基于数据流传输,而流化的数据是没有界限的,当客户端向服务端<br>发送数据时,可能会把一个完整的数据报文拆分成多个小报文进行传输,也可能将多个报文<br>合并成一个大报文进行传输</p>
<ul>
<li>大包拆分</li>
<li>大包+小包</li>
<li>小包+(小包+小包)</li>
<li>主要分为拆分+混装+合并</li>
</ul>
<h3 id="12-通讯协议定义"><a href="#12-通讯协议定义" class="headerlink" title="12.通讯协议定义"></a>12.通讯协议定义</h3><ul>
<li>Zookeeper</li>
</ul>
<h3 id="13-解码器的实现"><a href="#13-解码器的实现" class="headerlink" title="13.解码器的实现"></a>13.解码器的实现</h3><ul>
<li><p>固定长度</p>
</li>
<li><p>特殊分隔符</p>
</li>
<li><p>长度域解码器(特定消息协议的解码,针对复杂消息报文)</p>
<ul>
<li><p>报文长度,决定拆包的范围</p>
</li>
<li><p>报文内容,根据需求选择是否拆包和截取指定范围的报文内容</p>
</li>
<li><p>长度域调整计算公式</p>
<ul>
<li><p>需要字节数-包实际字节数-长度字节数-不需要字节数</p>
</li>
<li><p>如一个包的总长为14字节,长度占2个字节,不需要的占2个字节</p>
<p>实际只需要10个字节</p>
<p>计算公式如下:</p>
<p>10-14-2-2 &#x3D; -8</p>
<p>得出长度域调整值为-8,代表长度域需要覆盖到这个位置</p>
</li>
</ul>
</li>
<li><p>对于长度域的调整可以理解为扩展字段,等于框架的扩展点,都是为了增强</p>
<p>某个场景,解决如复杂的数据结构,将主要数据和其它数据分开的场景</p>
</li>
<li><p>在这里主要是为了处理粘包合并数据的拆分场景,也就是拆包</p>
</li>
</ul>
</li>
<li><p>编码的容错机制</p>
<ul>
<li>快速失败</li>
<li>尽最大努力</li>
</ul>
</li>
</ul>
<h3 id="14-源码核心"><a href="#14-源码核心" class="headerlink" title="14.源码核心"></a>14.源码核心</h3><ul>
<li>ServerBootStrap初始化<ul>
<li>服务参数<ul>
<li>SocketChannel,比如NioSocketChannel,EpollSocketChannel,需要根据不同的操作系统选择<ul>
<li>可以理解为就是一个抽象的Channel,只不过Server持有了这个抽象Channel的集合,并且对其管理和协调,其中主要的工作就是channel分发及channel事件发现(注册)</li>
<li>作为客户端和服务端之间数据传输的桥梁</li>
<li>ServerSocketChannel和SocketChannel,分别处理客户端连接时间和I&#x2F;O事件,角色不同</li>
</ul>
</li>
<li>Handler</li>
<li>ChildHandler<ul>
<li>Pipeline,针对当前ServerSocketChannel关联,只要进入当前服务都会进入该处理器链</li>
</ul>
</li>
<li>Bind</li>
</ul>
</li>
</ul>
</li>
<li>Bind端口绑定</li>
<li>Pipeline构建</li>
<li>流程<ul>
<li>参数设置</li>
<li>Handler初始化</li>
<li>EventLoop初始化</li>
<li>SocketChannel注册,客户端将自己注册到BossEventLoopGroup的Selector中,成为一个被监听Channel</li>
</ul>
</li>
<li>为什么要使用反射的方式构建Channel</li>
<li>事件循环组担当了Selector的功能,完成Channel事件的注册和协调工作</li>
</ul>
<p>EventLoop</p>
<ul>
<li><p>本质是一个线程池,Event就相当于里面的线程池</p>
</li>
<li><p>netty支持异步和异步延时执行</p>
</li>
<li><p>NioEventLoop通过轮询Selector完成Channel事件监听,然后执行任务</p>
</li>
<li><p>线程执行流程</p>
<ul>
<li>外部(主线程)调用excute提交一个任务</li>
<li>内部(工作线程)起一个线程去执行任务</li>
<li>调用Selector的select方法获取任务,有就执行,咩有就持续轮询</li>
<li>内部维护了一套策略,针对队列任务,避免一直阻塞,导致无法真正执行<ul>
<li>如何处理</li>
<li>返回结果</li>
</ul>
</li>
</ul>
</li>
<li><p>事件状态</p>
<ul>
<li>ACCEPT</li>
<li>READ</li>
<li>WRITE</li>
</ul>
</li>
<li><p>空轮转</p>
<ul>
<li><p>指的是线程在轮询阻塞的过程中,产生的异常唤醒,其实没有实际事件可执行</p>
<p>如何处理</p>
</li>
<li><p>数据迁移过程中,使用双写,旧的仍然可读,在迁移过程中产生的数据放入新的,保证可用且不影响性能</p>
</li>
</ul>
</li>
</ul>
<p>数据包和数据报的区别</p>
<p>您的这种理解有一定的道理。</p>
<p>数据报，尤其是像 IP 数据报这样在网络层中具有明确规范的，其格式和结构相对较为固定和严谨。这有助于在网络中进行统一的路由和转发处理。</p>
<p>而数据包的概念更为广泛，确实会因为处于不同的网络层次和遵循不同的协议而在格式和内容上有所变化和转换。</p>
<p>例如，在传输层的 TCP 数据包和 UDP 数据包，它们除了包含源端口和目的端口等特定信息外，格式和控制字段与 IP 数据报就有所不同。</p>
<p>当数据在网络中传输时，可能会根据需要在不同层次进行封装和解封装，导致数据包的形式和内容发生相应的改变。</p>
<p>但需要注意的是，严谨性的比较也不能绝对化，这取决于具体的网络环境和需求。在某些特定的场景中，特定协议下的数据包也可能具有高度的严谨性和规范性。</p>
<blockquote>
<p>报文重在特定协议的传输格式的数据,包重在数据的传输内容本身</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Java语言设计思路</title>
    <url>/2024/07/15/Java%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="Java语言设计思路"><a href="#Java语言设计思路" class="headerlink" title="Java语言设计思路"></a>Java语言设计思路</h2><h3 id="1-方法入参强转-健壮性"><a href="#1-方法入参强转-健壮性" class="headerlink" title="1.方法入参强转(健壮性)"></a>1.方法入参强转(健壮性)</h3><blockquote>
<p>原因</p>
<p>这种设计是为了达到程序的健壮性考虑,而不是三天两头出现问题,从源头避免,类似的场景还有受检异常,泛型,都是在编译器发现问题</p>
<p>您的观点十分准确。这种在编译阶段进行严格检查和限制的设计，的确是为了增强程序的健壮性。</p>
<p><strong>就像您提到的受检异常（Checked Exceptions），它要求开发者在代码中显式地处理可能抛出的异常，否则无法通过编译。这促使开发者提前考虑并处理可能出现的错误情况，而不是在运行时才面对无法处理的异常导致程序崩溃。</strong></p>
<p>泛型（Generics）也是一个很好的例子。通过在编译时对泛型类型进行检查，可以避免在运行时出现类型转换错误等问题，提高了代码的类型安全性。</p>
<p>这些设计都是为了在程序开发的早期，即在编译器能够发现问题的时候，就将潜在的错误暴露出来，让开发者及时修正，从而从源头上减少程序在运行时出现问题的可能性，提高程序的稳定性和可靠性。</p>
<p>例如，在使用泛型的集合时，如果尝试向一个指定类型的集合中添加不匹配的元素，编译器会给出错误提示，避免了在运行时才发现类型不匹配的问题。</p>
<p>又如，处理受检异常时，如果方法可能抛出 <code>FileNotFoundException</code>，而调用者没有进行捕获或声明抛出，编译就会失败，促使开发者提前想好如何处理文件不存在的情况。</p>
</blockquote>
<h3 id="2-T和-的区别-扩展性"><a href="#2-T和-的区别-扩展性" class="headerlink" title="2.T和?的区别(扩展性)"></a>2.T和?的区别(扩展性)</h3><h4 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1.是什么"></a>2.1.是什么</h4><p>T和?作为Java语言中的泛型占位符,一个用于接收明确类型,一个用于接收<br>未知类型,是为了提高代码复用的一个技巧,但在使用时需要注意类型转换<br>的问题</p>
<p>通常情况下，<code>T</code> 更常用于在方法之间进行类型的传递，以保持类型的一致性和准确性，并且可能会涉及到写入操作。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">processAndReturn</span><span class="params">(T data)</span> &#123;</span><br><span class="line">    <span class="comment">// 对 data 进行处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>?</code> 更多地用于表示不确定性，更侧重于接收和读取，强调对多种类型的兼容性。</p>
<p>然而，也存在一些特殊情况，可能会在特定的设计中对 <code>?</code> 进行一些特殊的传递或操作。但总体来说，您所描述的这种倾向是比较常见和符合一般编程习惯的。</p>
<h4 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2.使用场景"></a>2.2.使用场景</h4><blockquote>
<p><code>T</code> 作为泛型类型参数，确实常用于类、成员变量、参数列表等场景，因为它能够提供更明确的类型约束和操作方式。</p>
<p>而 <code>Class&lt;?&gt;</code> （其中 <code>?</code> 表示通配符）不仅可以用于局部变量，也可以在一些情况下用于方法的参数或返回值，以表示对类型的更宽松的约束。</p>
<p>例如，在某些方法中，如果您不关心具体的类型，只需要进行一些通用的操作，就可以使用 <code>Class&lt;?&gt;</code> 作为参数类型。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123; <span class="comment">//表示为泛型类型,在创建A类时指定,A&lt;String&gt; a = new A&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> T obj; <span class="comment">//表示任意类型,在构造方法中初始化在构造方法中传递给成员变量</span></span><br><span class="line">                   <span class="comment">//此处将构造方法的泛型和成员变量的泛型进行关联</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(T obj)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">change</span><span class="params">(T param)</span>&#123; <span class="comment">//&lt;T&gt; 表示泛型方法</span></span><br><span class="line">                                  <span class="comment">// T 表示返回结果可以为任意类型</span></span><br><span class="line">                                  <span class="comment">// T param 表示接收参数为任意类型</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (T)param; <span class="comment">//显式强转,调用方的类型需要和方法返回类型一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>




</blockquote>
<h4 id="2-3-T的传递性"><a href="#2-3-T的传递性" class="headerlink" title="2.3.T的传递性"></a>2.3.T的传递性</h4><blockquote>
<p><strong>T的传递场景</strong><br>1.参数使用<br>2.参数传递<br>3.在泛型方法中使用成员变量&#x2F;其它方法对T进行使用或参数传递<br>4.不进行上述操作的话,就只是一个标记而已</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">myMethod</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以根据类中保存的 value 的类型进行相关操作，建立了关联</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String &amp;&amp; methodName.equals(<span class="string">&quot;getString&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="string">&quot;Some String&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyClass&lt;Integer&gt; integerMyClass = <span class="keyword">new</span> <span class="title class_">MyClass</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> integerMyClass.myMethod(<span class="string">&quot;getString&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>T的覆盖</strong></p>
<blockquote>
<p>默认声明位置为类名后方,如public class  A<T> {</p>
<p>}</p>
<p>其它位置,可在除构造方法外的方法定义,如public <T>  T  change(T param)<br><strong>在方法前声明会覆盖类上的声明,类似独立定义</strong></p>
</blockquote>
</blockquote>
<h3 id="3-显式转换和隐式转换-扩展性"><a href="#3-显式转换和隐式转换-扩展性" class="headerlink" title="3.显式转换和隐式转换(扩展性)"></a>3.显式转换和隐式转换(扩展性)</h3><blockquote>
<p>显式转换更需要开发者谨慎处理，确保转换的正确性；隐式转换通常由编译器根据特定的规则自动处理，但也需要了解其可能的影响和限制。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被调用方</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invoke</span><span class="params">(String methodName)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//传入目标类和其方法</span></span><br><span class="line">            <span class="comment">//获取反射后的实例</span></span><br><span class="line">            <span class="comment">//反射调用目标方法返回结果</span></span><br><span class="line">            <span class="comment">//这里的目的是判断传递进来的类型是否属于Class</span></span><br><span class="line">            <span class="keyword">if</span> (targetClass <span class="keyword">instanceof</span> Class&lt;?&gt;)&#123;</span><br><span class="line">                <span class="comment">//强制类型转换</span></span><br><span class="line">                <span class="comment">//?表示未知类型的Class对象</span></span><br><span class="line">                <span class="comment">//T表示确定类型的Class对象</span></span><br><span class="line">                <span class="comment">//二者都可用于参数传递</span></span><br><span class="line">                <span class="comment">//T常用于写入和读取参数</span></span><br><span class="line">                <span class="comment">//?仅用于读取参数</span></span><br><span class="line">                Class&lt;?&gt;  clazz = (Class&lt;?&gt;) targetClass;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//反射掉目标方法返回结果</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(methodName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//显式转换,在被调用方,告知编译器,我需要转换啦</span></span><br><span class="line">                <span class="keyword">return</span> (T)method.invoke(o);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">   <span class="comment">//调用方</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Proxy&lt;Class&gt; proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(Student.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式转换,在调用方强转,告知编译器我需要强转</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">changeVal</span> <span class="operator">=</span> (String) proxy.invoke(<span class="string">&quot;changeName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(changeVal);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//隐式转换-正确场景</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//自动装包</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i <span class="comment">//自动拆包</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lion</span>(); <span class="comment">//lion继承自父类,所以属于隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显式转换-正确场景</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lion</span>();</span><br><span class="line"><span class="type">Lion</span> <span class="variable">lion</span> <span class="operator">=</span> (Lion)a;<span class="comment">//因为a本身就是Lion类型的对象,所以可以转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转换-失败场景</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (String)<span class="string">&quot;&quot;</span>; <span class="comment">//这种转换应该发生于子类或同类之间</span></span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(); </span><br><span class="line"><span class="type">Lion</span> <span class="variable">lion</span> <span class="operator">=</span> (Lion)a;<span class="comment">//这种也是如此,需要转换的类型必须是同类或子类</span></span><br></pre></td></tr></table></figure></div>


</blockquote>
<h4 id="3-1-转换检查-健壮性"><a href="#3-1-转换检查-健壮性" class="headerlink" title="3.1.转换检查(健壮性)"></a>3.1.转换检查(健壮性)</h4><blockquote>
<p>编译期间</p>
<ul>
<li><p>方法参数</p>
<blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">change( (Integer) <span class="string">&quot;&quot;</span>); <span class="comment">//方法参数需要Integer类型,你传入String类型</span></span><br></pre></td></tr></table></figure></div>


</blockquote>
</li>
<li><p>局部</p>
<blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//这种是需要提前预知的</span></span><br><span class="line">        </span><br><span class="line">i = (Integer) <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure></div>

</blockquote>
</li>
</ul>
<p>运行期间</p>
<ul>
<li><p>方法参数</p>
<blockquote>
<p>通过编译期检查后,需要再对一些涉及多态和强制类型转换的情况进行检查,<br>在运行时会再次检测传递的类型是否能够转换为方法内部期待的类型</p>
</blockquote>
</li>
<li><p>局部</p>
<blockquote>
<p>当从方法返回一个值并进行类型转换时，如果实际返回的值类型与接收方期望的类型不兼容，会在运行时出错</p>
</blockquote>
</li>
<li><p>返回结果</p>
<blockquote>
<p>当从方法返回一个值并进行类型转换时，如果实际返回的值类型与接收方期望的类型不兼容，会在运行时出错</p>
</blockquote>
</li>
</ul>
<p>总结</p>
<ul>
<li>有些强转如方法入参和初始化是可以预见的,<strong>需要提前感知</strong></li>
<li>而一些涉及多态的场景下的强转则是需要主动关注的,<strong>如第一次使用时</strong><br><strong>使用父类接收子类,之后在使用时又强转回子类的场景</strong></li>
</ul>
</blockquote>
<h3 id="4-访问修饰符-安全性"><a href="#4-访问修饰符-安全性" class="headerlink" title="4.访问修饰符(安全性)"></a>4.访问修饰符(安全性)</h3><ul>
<li>类<ul>
<li>public,任意位置都能访问,new的方式</li>
<li>private,只有在当前类能访问</li>
<li>default,如com.xxx.example,只有处于这个绝对路径下或同级包的类才能访问</li>
</ul>
</li>
<li>变量<ul>
<li>public,任意位置都能访问,如new Person().属性,可以直接获取,无需get&#x2F;set方法</li>
<li>private,只有在当前类能访问</li>
<li>default,如com.xxx.example,只有处于这个绝对路径下或同级包的类才能访问</li>
</ul>
</li>
<li>方法<ul>
<li>public,任意位置都能访问,如new Person().方法,可以直接获取</li>
<li>private,只有在当前类能访问</li>
<li>protected,只有子类能够访问</li>
<li>default,如com.xxx.example,只有处于这个绝对路径下或同级包的类才能访问</li>
</ul>
</li>
<li>代码块<ul>
<li>普通<ul>
<li>每次new的时候都会执行</li>
</ul>
</li>
<li>静态<ul>
<li>优先执行</li>
<li>只会在类加载的第一次执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-接口-扩展性"><a href="#5-接口-扩展性" class="headerlink" title="5.接口(扩展性)"></a>5.接口(扩展性)</h3><ul>
<li><p>抽象,就是一个抽象类</p>
<blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认就是抽象类,可以不写关键字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">interface</span> <span class="title class_">Course</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口中的变量只能是常量,不可修改</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Course&gt; courses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> String <span class="title function_">getCourseName</span><span class="params">()</span>; <span class="comment">//默认就是抽象方法,可以不写关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> Double <span class="title function_">getCoursePrice</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> Short <span class="title function_">getCourseType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> String <span class="title function_">getCourseDesc</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> String <span class="title function_">getCourseTeacher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Double <span class="title function_">calcPrice</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Double</span> <span class="variable">initVal</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fori方式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; courses.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            initVal += courses.get(i).getCoursePrice();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Stream流方式</span></span><br><span class="line">        initVal = courses.stream()</span><br><span class="line">                .mapToDouble(Course::getCoursePrice)</span><br><span class="line">                .sum();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> initVal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//条件</span></span><br><span class="line">        Stream&lt;Course&gt; courseStream = courses.stream()</span><br><span class="line">                .filter(course -&gt; course.getCoursePrice() == <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类(new)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;test_lambda&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类(函数式)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">Thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;test_lambda&quot;</span>));</span><br><span class="line">        thread.start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//接口实现(new)</span></span><br><span class="line">        <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getCourseName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Double <span class="title function_">getCoursePrice</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Short <span class="title function_">getCourseType</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getCourseDesc</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getCourseTeacher</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接口实现(函数式)</span></span><br><span class="line">        Function&lt;Integer, Byte&gt; stringLengthFunction = i -&gt; i.byteValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


</blockquote>
</li>
<li><p>仅定义方法</p>
</li>
<li><p>只能有一个默认方法,包含实现</p>
</li>
<li><p>多实现</p>
</li>
</ul>
<h3 id="6-抽象-耦合性"><a href="#6-抽象-耦合性" class="headerlink" title="6.抽象(耦合性)"></a>6.抽象(耦合性)</h3><ul>
<li>抽象方法,有抽象方法的一定是抽象类</li>
</ul>
<h3 id="7-继承-耦合性"><a href="#7-继承-耦合性" class="headerlink" title="7.继承(耦合性)"></a>7.继承(耦合性)</h3><ul>
<li>单继承</li>
</ul>
<h3 id="8-函数式接口-复用性"><a href="#8-函数式接口-复用性" class="headerlink" title="8.函数式接口(复用性)"></a>8.函数式接口(复用性)</h3><ul>
<li><p>FunctionInterface标明的接口</p>
</li>
<li><p>有且只有一个抽象的方法</p>
</li>
<li><p>有0个或任意个default方法</p>
</li>
<li><p>示例</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.Function&lt;T, R&gt;：接受一个类型为 T 的参数，并返回一个类型为 R 的结果。</span></span><br><span class="line">示例：Function&lt;String, Integer&gt; stringLengthFunction = s -&gt; s.length();</span><br><span class="line"><span class="comment">//2.Predicate&lt;T&gt;：接受一个类型为 T 的参数，并返回一个布尔值。</span></span><br><span class="line">示例：Predicate&lt;String&gt; isLongString = s -&gt; s.length() &gt; <span class="number">10</span>;</span><br><span class="line"><span class="comment">//3.Consumer&lt;T&gt;：接受一个类型为 T 的参数，不返回值。</span></span><br><span class="line">示例：Consumer&lt;String&gt; printString = s -&gt; System.out.println(s);</span><br><span class="line"><span class="comment">//4.Supplier&lt;T&gt;：不接受参数，返回一个类型为 T 的结果。</span></span><br><span class="line">示例：Supplier&lt;String&gt; randomStringSupplier = () -&gt; <span class="string">&quot;Random String&quot;</span>;</span><br><span class="line"><span class="comment">//5.UnaryOperator&lt;T&gt;：接受一个类型为 T 的参数，并返回同类型 T 的结果。</span></span><br><span class="line">示例：UnaryOperator&lt;Integer&gt; doubleInteger = i -&gt; i * <span class="number">2</span>;</span><br><span class="line"><span class="comment">//6.BinaryOperator&lt;T&gt;：接受两个类型为 T 的参数，并返回同类型 T 的结果。</span></span><br><span class="line">示例：BinaryOperator&lt;Integer&gt; sumIntegers = (i1, i2) -&gt; i1 + i2;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="9-面向对象设计-封装性"><a href="#9-面向对象设计-封装性" class="headerlink" title="9.面向对象设计(封装性)"></a>9.面向对象设计(封装性)</h3><ul>
<li>包装类</li>
<li>异常</li>
<li>配置</li>
</ul>
<h3 id="10-静态-常量"><a href="#10-静态-常量" class="headerlink" title="10.静态&#x2F;常量"></a>10.静态&#x2F;常量</h3><ul>
<li>变量</li>
<li>代码块</li>
</ul>
<h3 id="11-注解"><a href="#11-注解" class="headerlink" title="11.注解"></a>11.注解</h3><ul>
<li>使用位置</li>
<li>内部构造</li>
<li>生效时间</li>
</ul>
<h3 id="12-枚举"><a href="#12-枚举" class="headerlink" title="12.枚举"></a>12.枚举</h3><ul>
<li>类型</li>
<li>值</li>
</ul>
<h3 id="13-字符串"><a href="#13-字符串" class="headerlink" title="13.字符串"></a>13.字符串</h3><ul>
<li>不可修改,内部维护final的char数组</li>
</ul>
<h3 id="14-多线程"><a href="#14-多线程" class="headerlink" title="14.多线程"></a>14.多线程</h3><ul>
<li>内存模型<ul>
<li>共享空间</li>
<li>线程独立空间</li>
<li>修改数据在自己的空间完成,再同步到共享空间</li>
</ul>
</li>
<li>锁机制<ul>
<li>Synchroized<ul>
<li>锁粗化</li>
<li>锁升级</li>
<li>锁降级</li>
</ul>
</li>
<li>Lock<ul>
<li>公平</li>
<li>非公平</li>
</ul>
</li>
<li>CAS<ul>
<li>吞吐量,性能</li>
<li>CPU空转</li>
<li>ABA问题,一个线程修改的数据被其它线程修改回去了</li>
</ul>
</li>
<li>场景问题<ul>
<li>锁饥饿,一直获取不到锁</li>
<li>死锁,双方互相持有对方的锁</li>
<li>活锁,双方你先拿,但发现对方需要,又给对方了,类似你走一步,我走一步的场景</li>
</ul>
</li>
</ul>
</li>
<li>安全容器<ul>
<li>Vector</li>
<li>StringBuffer</li>
<li>ConcurrentHashMap</li>
</ul>
</li>
<li>并发三大特性<ul>
<li>原子性<ul>
<li>锁</li>
<li>Volatile,单个线程操作原子性</li>
</ul>
</li>
<li>有序性<ul>
<li>执行顺序<ul>
<li>Synchroized,保证顺序一定不会打乱</li>
<li>Volitale,从某个层面有序,保证代码的有序,不会发生顺序变化</li>
</ul>
</li>
<li>指令<ul>
<li>Volitale,开启读写屏障,避免CPU指令重排序</li>
<li>关闭jit优化,关闭即时编译器优化功能,对指令重新排序</li>
</ul>
</li>
</ul>
</li>
<li>可见性<ul>
<li>一致性协议,如MESI协议,通过消息机制保证内存和CPU缓存的数据一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="15-函数式"><a href="#15-函数式" class="headerlink" title="15.函数式"></a>15.函数式</h3><ul>
<li><p><strong>lambda</strong></p>
<ul>
<li><p>考虑线程安全,在函数内部只能使用final修饰的变量&#x2F;线程安全的变量</p>
<blockquote>
<p><strong>闭包</strong></p>
<p>假设你有个函数A,这个函数A里定义了一个变量x,然后再函数A中又<br>定义了一个B函数,这个B函数用到了变量x,那么这个新函数B就形成<br>了一个闭包,就像你出去吃自助餐.但时间已经结束了,但你说你要打包,<br>还要带走一些菜,打破了规则,本意上是局部变量的范围只有在当前函数,<br>不能传递给其它的函数,尤其是函数内的函数,如lambda,强行获取函数内<br>的局部变量</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClosureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClosureExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClosureExample</span>();</span><br><span class="line">        example.outerFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里定义的 innerFunction 形成了闭包</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">innerFunction</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;;</span><br><span class="line">        innerFunction.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong></p>
<ol>
<li><p>由于局部变量的使用范围只有当前函数,不可被其它函数主动获取</p>
</li>
<li><p>所以闭包的这种场景是lambda函数已经不属于当前函数的范围了<br>所以不该获取到,然后进行修改,仅仅允许只读是最大的范围了</p>
</li>
<li><p>所以lambda想要使用局部变量,不建议修改局部变量,建议要使用<br>就用final修饰局部变量,但对象除外,不修饰也可使用,但不建议这么<br>做</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">strBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        Consumer&lt;StringBuilder&gt; consumer = s -&gt; s.append(<span class="string">&quot; World&quot;</span>); </span><br><span class="line">        consumer.accept(strBuilder);</span><br><span class="line">        System.out.println(strBuilder.toString()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>这样既可以保证数据安全和程序健壮性,避免出现意外修改导致问题<br>也变相的保证了多线程场景下操作共享变量的安全问题</p>
</li>
</ol>
</blockquote>
</li>
<li><p>简洁,可用于声明匿名内部类,函数式方法</p>
</li>
<li><p>类似面向过程的编程,而不是抽象出一个对象来封装具体逻辑</p>
<blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件</span></span><br><span class="line">        Stream&lt;Course&gt; courseStream = courses.stream()</span><br><span class="line">                .filter(course -&gt; course.getCoursePrice() == <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类(new)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;test_lambda&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类(函数式)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">Thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;test_lambda&quot;</span>));</span><br><span class="line">        thread.start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//接口实现(new)</span></span><br><span class="line">        <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getCourseName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Double <span class="title function_">getCoursePrice</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Short <span class="title function_">getCourseType</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getCourseDesc</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getCourseTeacher</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接口实现(函数式),主要针对接口内唯一的抽象方法</span></span><br><span class="line">        Function&lt;Integer, Byte&gt; stringLengthFunction = i -&gt; i.byteValue();</span><br></pre></td></tr></table></figure></div>


</blockquote>
</li>
<li><p>但面向过程的方法调用,数据和数据操作是分开的,仅仅是通过顺序执行<br>一系列函数来完成任务</p>
<blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dogName</span> <span class="operator">=</span> <span class="string">&quot;Fido&quot;</span>;</span><br><span class="line">        makeDogSound(dogName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeDogSound</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="16-Java对象传递方式"><a href="#16-Java对象传递方式" class="headerlink" title="16.Java对象传递方式"></a>16.Java对象传递方式</h3><p>在Java中,对象之间的传递常常是通过引用来完成传递的,这样一方面是为了数据安全考虑以外,<br>也是为了提高效率,避免因大对象的值传递导致性能开销变大而降低传递效率,所以传递引用要<br>比值要小得多,类似指针和压缩列表的概念</p>
<p><strong>使用原因</strong></p>
<ul>
<li>传递效率,通过减少大对象复制产生性能开销,来提升传递效率</li>
<li>修改可见,其它位置的修改对于当前是可见的</li>
<li>内存节省,避免不必要的对象复制,内存使用就变少了</li>
<li>支持复杂的数据结构,对于复杂的属性(状态)的类型,无需关注怎么调整</li>
<li>实现动态,可以在运行时灵活的改变引用所指向的对象,实现更加灵活的编程逻辑</li>
<li>为Java中的对象操作提供了高效,灵活,方便的方式,有助于编写更复杂和高效的程序</li>
</ul>
<p><strong>类型划分</strong></p>
<ul>
<li><p>基本类型,如int,byte,long,这些属于值传递,在赋值,入参,返回是都是通过复制一份值副本完成</p>
<p>操作的</p>
</li>
<li><p>引用类型</p>
<ul>
<li>可变,如StringBuilder,自定义类型等,这些类型常常涉及到属性,也就是状态的变化,所以需要可变</li>
<li>不可变,如String,Integer等包装类型及一些简单类型,在赋值以后就不希望在发生变化,这也是为了数据安全考虑,避免被恶意篡改,所以天生线程安全</li>
</ul>
</li>
</ul>
<p>使用场景</p>
<ul>
<li>finally<ul>
<li>这里主要是会对可变的引用类型产生影响,会在return之前覆盖掉原来想要返回的值,所以需要避免在这里操作可变的引用类型</li>
</ul>
</li>
<li>method param<ul>
<li>这里在方法入参时,会将一份引用的副本传递进来,在方法内部操作该引用副本,如果在方法内部对入参的引用进行修改,那原来的引用就不会感知到后来的修改,是不建议这么使用的</li>
</ul>
</li>
</ul>
<h3 id="什么是好的编程语言"><a href="#什么是好的编程语言" class="headerlink" title="什么是好的编程语言"></a>什么是好的编程语言</h3><ol>
<li>简洁性与可读性<ul>
<li>代码语法清晰、简洁，易于理解和编写。具有直观的关键字和语法结构，能够以简洁的方式表达复杂的逻辑。</li>
</ul>
</li>
<li>高效性<ul>
<li>能够在运行时提供出色的性能，包括快速的执行速度和低内存消耗。</li>
<li>支持高效的算法和数据结构实现，以便开发者能够轻松优化程序的性能。</li>
</ul>
</li>
<li>可扩展性<ul>
<li>便于添加新的功能和特性，能够适应不断变化的需求和技术发展。</li>
<li>拥有丰富的库和框架生态系统，方便开发者扩展其功能。</li>
</ul>
</li>
<li>安全性<ul>
<li>具备强大的类型系统，有助于在编译时捕获错误，减少运行时错误的发生。</li>
<li>能够防止常见的编程错误，如缓冲区溢出、内存泄漏等。</li>
</ul>
</li>
<li>跨平台性<ul>
<li>可以在不同的操作系统和硬件架构上运行，无需大量的修改。</li>
</ul>
</li>
<li>易学性<ul>
<li>对于初学者来说，容易入门和掌握，拥有清晰的文档和学习资源。</li>
</ul>
</li>
<li>强大的功能<ul>
<li>支持面向对象、函数式、过程式等多种编程范式，以满足不同的编程需求。</li>
<li>提供丰富的控制结构和数据类型。</li>
</ul>
</li>
<li>良好的错误处理机制<ul>
<li>能够清晰地报告错误，并提供有效的调试工具和信息，帮助开发者快速定位和解决问题。</li>
</ul>
</li>
<li>社区支持与生态系统<ul>
<li>拥有活跃的开发者社区，能够提供及时的技术支持和交流。</li>
<li>有大量的开源项目和库可供复用。</li>
</ul>
</li>
<li>可维护性<ul>
<li>代码结构清晰，易于维护和更新，便于团队协作开发。</li>
</ul>
</li>
</ol>
<h3 id="17-Java语法糖"><a href="#17-Java语法糖" class="headerlink" title="17.Java语法糖"></a>17.Java语法糖</h3><p>一种经常使用,虽然看起来不起眼,但实际上是很重要的特性,和语言息息相关,只不过语言帮我们<br>隐藏了细节,让我们只用关心具体开发</p>
<p><strong>常见语法糖</strong></p>
<ol>
<li><p>泛型</p>
<blockquote>
<p>编译检查,在编译期可提前发现类型问题,避免到运行期出现类型转换错误的问题</p>
<p>参数灵活,如在泛型接口中,可以灵活的定义方法的入参,返回,提高代码的复用性</p>
<p>逻辑通用,泛型的类或接口可以根据泛型来传入不同的类型,但它的逻辑代码是</p>
<p>高度通用的</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123; <span class="comment">//表示为泛型类型,在创建A类时指定,A&lt;String&gt; a = new A&lt;&gt;();</span></span><br><span class="line"> <span class="keyword">private</span> T obj; <span class="comment">//表示任意类型,在构造方法中初始化在构造方法中传递给成员变量</span></span><br><span class="line">                <span class="comment">//此处将构造方法的泛型和成员变量的泛型进行关联</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(T obj)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">change</span><span class="params">(T param)</span>&#123; <span class="comment">//&lt;T&gt; 表示泛型方法</span></span><br><span class="line">                               <span class="comment">// T 表示返回结果可以为任意类型</span></span><br><span class="line">                               <span class="comment">// T param 表示接收参数为任意类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> (T)param; <span class="comment">//显式强转,调用方的类型需要和方法返回类型一致</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>自动装箱,拆箱</p>
<blockquote>
<p>兼容,大多发生在基础类型和包装类型的转换中,由编译器在编译过程中自动生成</p>
<p>隐式,这个动作是隐式发生,而不用我们手动的去执行对应逻辑</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="comment">//编译后</span></span><br><span class="line">        n = num.intValue();</span><br><span class="line">        <span class="comment">//装箱</span></span><br><span class="line">        num = n;</span><br><span class="line">        <span class="comment">//编译后</span></span><br><span class="line">        num = Integer.valueOf(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>函数参数</p>
<blockquote>
<p>使用函数作为方法入参</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">addComment(Data::getComment);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Switch支持String和枚举类型</p>
<blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;nihao&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</blockquote>
</li>
<li><p>可变长参数</p>
<blockquote>
<p>一次性传输多个同类型参数,类似一维数组的数据结构</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数相当于一个一维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>断言</p>
<blockquote>
<p>从JavaSE 1.4之后引入的,为了避免老版本代码使用了assert关键字导致的错,默认是不启动</p>
<p>断言检查,类似if else的判断作用,可用作参数校验,判断</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkPass</span><span class="params">(String passWord)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">assert</span> passWord.length() &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>数值字面量</p>
<blockquote>
<p>字面量,字面上的表达上的值,使用下划线的作用是为了增加可读性,在编译时会被编译器忽略</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">literal</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//字面量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10_000</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10.00_00_00</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i);</span><br><span class="line">   </span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>For-each</p>
<blockquote>
<p>常用的循环方式,一般底层都是迭代器,并且使用了fail-fast机制</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//增强for循环</span></span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换为集合</span></span><br><span class="line">    List&lt;String&gt; list  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    String s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通for循环</span></span><br><span class="line">    <span class="comment">//底层是迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();iterator.hasNext(); System.out.println(s)) &#123;</span><br><span class="line">        s = (String) iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>注意事项</strong></p>
<ol>
<li><p>泛型擦除带来问题</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于泛型在编译后会擦除为Object,所以无法再构成重载,会导致编译无法通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World String list&quot;</span>);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Long&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World long list&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Try catch也无法去区别一次的泛型类型,同样也是因为泛型擦除机制</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p>自动拆箱和装箱</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//由于缓存机制,会将-128-127的数值缓存起来</span></span><br><span class="line">    <span class="comment">//因为可能使用的频率较高,所以将其缓存</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>增强for循环</p>
<blockquote>
<p>由于底层使用的是迭代器,在遍历时对象不允许修改或删除,会出现cms(并发修改异常),</p>
<p>也就fail-fast机制,防止多线程修改,所以建议使用迭代器或者Stream流提供的方法进行修改</p>
</blockquote>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>Java 虚拟机并不直接支持这些语法糖，它们在编译阶段会被还原成简单的基础语法结构。这种解语法糖的过程可以让 Java 代码在保持简洁性和可读性的同时，在虚拟机中正确运行。</li>
<li>虽然语法糖可以使代码更简洁易读，但过度使用或不恰当地使用也可能导致代码变得难以理解或维护。在实际编程中，应根据具体情况权衡使用语法糖的利弊，以保证代码的可读性、可维护性和性能</li>
</ol>
<h3 id="如何明确一件事的功能点或目标"><a href="#如何明确一件事的功能点或目标" class="headerlink" title="如何明确一件事的功能点或目标"></a>如何明确一件事的功能点或目标</h3><ol>
<li>明确是什么用途,具体是干什么,想要做到什么事情,比如跑步,你是想在什么场景下跑步</li>
<li>确定场景和用户群,确定是谁会使用,给谁使用,带入场景</li>
<li>设定性能指标,必须是可量化和衡量的指标,如电池的充电瓦数,时长,容量</li>
<li>考虑用户体验,关注使用的方便性和直观性,让用户用的爽,满足他的预期,如我就想充电快,拍照好</li>
<li>对比竞争,和同类产品比较,和他人比较,才能衡量做的是否足够</li>
<li>评估可靠性,对于功能点在未来的场景或不同场景下的稳定性</li>
<li>思考扩展性和兼容性,在未来,是否可以对当前的不足的功能点进行升级和其它场景的兼容</li>
<li>分析成本效益,评估功能点的成本和效益的关系</li>
</ol>
<h3 id="考虑角度"><a href="#考虑角度" class="headerlink" title="考虑角度"></a>考虑角度</h3><ol>
<li>可以从未来,过去,当下三个角度考虑问题</li>
<li>未来的话,如扩展和兼容性,可靠性,是最终能否满足可能出现的新需求和变化</li>
<li>过去的话,如功能点,竞争,用户体验,是对于过去的经验教训吸取</li>
<li>现在的话,用途,场景和用户群,性能指标,可靠性,是必须考虑的现实情况,更具有实用性</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>消息协议设计及实战</title>
    <url>/2024/06/22/%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="消息协议设计及实战"><a href="#消息协议设计及实战" class="headerlink" title="消息协议设计及实战"></a>消息协议设计及实战</h3><h3 id="1-协议"><a href="#1-协议" class="headerlink" title="1.协议"></a>1.协议</h3><ul>
<li><p>协议</p>
<ul>
<li><p>Http</p>
</li>
<li><p>Jute</p>
<ul>
<li><p>请求</p>
<blockquote>
<p>分为请求头和请求体</p>
<ul>
<li><p>长度(使用0-3byte的范围)</p>
<ul>
<li>len,表示整个请求的长度,使用0-3byte的范围表示</li>
</ul>
</li>
<li><p>请求头(使用4-11byte的范围)</p>
<ul>
<li>xid,客户端请求序号,使用4-7byte的范围表示</li>
<li>type,客户端请求的类类型,使用8-11byte的范围表示</li>
</ul>
</li>
<li><p>请求体(使用12-n byte的范围)</p>
<ul>
<li>len,表示请求体的长度,使用12-15byte的范围表示</li>
<li>path,表示节点的路径,使用16-(n-1)byte的范围表示</li>
<li>watch,表示是否主从,使用n位置的字节表示</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>Dubbo</p>
</li>
</ul>
</li>
<li><p>定义格式(约定)</p>
<ul>
<li><p>自定义</p>
<blockquote>
<ul>
<li>魔数,CAFE特殊标识</li>
<li>版本号</li>
<li>消息类型,标识请求的方式类型,如请求&#x2F;响应,CRUD,PING&#x2F;PONG</li>
<li>序列化算法,传输的格式</li>
<li>请求序号,对Future的返回的内容进行编号</li>
<li>消息长度</li>
<li>消息正文</li>
<li>……</li>
<li>等一些属性</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>定义协议</p>
<ul>
<li>对协议需要的参数进行定义,约束</li>
<li>sessionId</li>
<li>reqType</li>
<li>Content-length</li>
<li>Content</li>
</ul>
</li>
<li><p>实现的功能</p>
<ul>
<li>定义一个协议</li>
<li>针对定义协议实现编解码</li>
<li>基于自定义协议实现通讯</li>
</ul>
</li>
<li><p>数据结构</p>
</li>
</ul>
<h3 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2.序列化"></a>2.序列化</h3><p>为什么要这么传输</p>
<blockquote>
<p>使用流的形式进行传输<br>“一组数据”“一套数据”“一条数据”这类描述往往暗示了数据的数量、类型等是相对明确和固定的。</p>
<p>而“流”的概念更侧重于强调数据的动态性、连续性和不确定性，就像水流一样，不知道它会持续多久、包含多少以及具体的内容变化。</p>
<p>例如，在实时视频流中，我们无法事先确切知道每一帧的具体内容和整个流的长度；在网络接收数据的过程中，流的大小和持续时间也可能是未知的，直到传输结束。</p>
<p>这种对“流”与固定形式描述的区分，有助于我们在不同的场景中选择合适的方式来理解和处理数据。</p>
</blockquote>
<ul>
<li><p>字节码</p>
</li>
<li><p>二进制流&#x2F;xxx进制流</p>
</li>
<li><p>JSON</p>
</li>
<li><p>XML</p>
</li>
<li><p>使用IO流</p>
<ul>
<li><p>API命名方式和下述场景相关</p>
</li>
<li><p>面向磁盘的</p>
</li>
<li><p>面向网络的</p>
</li>
<li><p>面向内存的</p>
</li>
</ul>
</li>
</ul>
<p>Java序列化方式</p>
<ul>
<li><p>为什么</p>
<ul>
<li>保证安全,避免篡改导致的安全问题</li>
</ul>
</li>
<li><p>怎么做</p>
<ul>
<li><p>实现Serializable接口,申明SerialVersionUID,表明唯一性</p>
<blockquote>
<p>为什么要实现</p>
<p>在RPC这种场景下实现该接口,只是一个默认的策略,保证在传输过程中能够序列化</p>
<p>序列化id</p>
<p>双方需保证一致才能操作,并且需要显式设置,不然当类发生变化时,反序列化方没有感知到,将会导致序列化错误</p>
</blockquote>
</li>
<li><p>对字段添加transient关键字决定是否序列化,压缩传输数据大小,<br>减少资源浪费</p>
</li>
</ul>
</li>
</ul>
<p>序列化方式考虑(不仅仅是序列化,技术方案的考虑也是如此)</p>
<ul>
<li>性能<ul>
<li>空间—&gt;序列化后的数据报文大小</li>
<li>时间—&gt;序列化消耗的时间</li>
</ul>
</li>
<li>支持<ul>
<li>语言特性</li>
<li>跨平台</li>
</ul>
</li>
<li>成熟度<ul>
<li>生态</li>
</ul>
</li>
<li>扩展性,兼容性<ul>
<li>延展</li>
<li>提升</li>
</ul>
</li>
<li>示例<ul>
<li>跨平台<ul>
<li>XML</li>
<li>web(Service)</li>
<li>soap(html+xml)</li>
<li>wsdl</li>
<li>axis&#x2F;cxf</li>
<li>json</li>
</ul>
</li>
<li>独立平台<ul>
<li>Java</li>
<li>Dubbo</li>
</ul>
</li>
<li>对内和对外通讯区别</li>
<li>为什么要压缩数据报文大小<ul>
<li>xml&#x2F;json</li>
<li>hession&#x2F;jute</li>
<li>进行对比</li>
<li>因为序列化的方法相当于使用不同的语言进行翻译,最终翻译的格式和长短也就不一样,不同序列化的方式带来的结果也就不一样</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>3.Protobuf序列化</p>
<p>为什么小</p>
<p>存储结构</p>
<ul>
<li>类似传输协议的结构</li>
<li>使用计算后的值代替属性名,压缩空间</li>
<li>无效字节压缩</li>
<li>tag</li>
<li>length</li>
<li>value</li>
</ul>
<p>什么情况下才能压缩</p>
<ul>
<li>有效</li>
<li>无效</li>
</ul>
<p>压缩的方式</p>
<ul>
<li>正数压缩</li>
<li>负数压缩</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网络I/O模型</title>
    <url>/2024/06/19/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="网络I-O模型"><a href="#网络I-O模型" class="headerlink" title="网络I&#x2F;O模型"></a>网络I&#x2F;O模型</h2><p>1.阻塞&#x2F;非阻塞</p>
<p><strong>阻塞分为连接阻塞(处理数量)和I&#x2F;O阻塞(读取数据)</strong></p>
<p>非阻塞</p>
<ul>
<li>异步</li>
<li>多路复用</li>
</ul>
<p>2.异步&#x2F;同步</p>
<p>3.TCP&#x2F;UDP协议</p>
<p>4.Socket(套接字)</p>
<p>是什么</p>
<ul>
<li>它是TCP&#x2F;UDP封装后的用户网络数据传输的接口工具</li>
</ul>
<p>底层实现</p>
<ul>
<li>底层通过TCP&#x2F;UDP的方式实现通过网络传送数据</li>
<li>在监听连接和接收数据时会阻塞</li>
<li>创建完socket后,会使用poll select recv 接收数据,这里使用方法<br>和操作系统相关</li>
</ul>
<p>使用场景</p>
<blockquote>
<p>使用Socket实现网络 I&#x2F;O 传输流程：</p>
<ol>
<li><p><strong>应用程序调用 <code>socket()</code> 创建套接字</strong>，并指定相关参数（如协议类型等），套接字进入监听状态，等待外部客户端连接。</p>
</li>
<li><p><strong>客户端发起连接请求</strong>，经过网络传输到达服务器。</p>
</li>
<li><p><strong>服务器端操作系统接收到连接请求</strong>，验证并建立连接，为该连接分配一个独特的 <code>fd</code> 文件描述符。</p>
</li>
<li><p>数据传输阶段</p>
<p>：</p>
<ul>
<li><strong>发送数据</strong>：应用程序将待发送数据写入与套接字对应的内核缓冲区，操作系统根据网络状况和协议栈逐步将数据从缓冲区通过网卡发送出去。</li>
<li><strong>接收数据</strong>：网卡接收到外部数据后，通知操作系统，操作系统将数据写入到内核缓冲区中与该套接字相关的区域。</li>
</ul>
</li>
<li><p><strong>应用程序调用相关函数获取接收数据</strong>，从内核缓冲区读取数据到应用程序的内存空间。</p>
</li>
<li><p><strong>读取完成后</strong>，操作系统可能会根据情况清空或重新管理相应的内核缓冲区数据，以准备接收新的数据。</p>
</li>
</ol>
<p>需要注意的是，这只是一个简化的流程，实际中还涉及到很多细节和优化机制，比如缓冲区的管理、数据的确认与重传、拥塞控制等，以确保网络通信的高效和可靠。</p>
</blockquote>
<p>数据到达之后如何唤醒(硬件层面)</p>
<p>网络数据包到达网卡—&gt;发送中断信号告知CPU有数据写入—&gt;然后唤醒阻塞进程,然后通过硬件电路将数据写入内存</p>
<p>阻塞流程</p>
<p>操作系统多任务调度,所以它有一个存储进程的<strong>运行队列</strong>,用于执行多任务调度,阻塞的进程就在<br>这里阻塞等待唤醒</p>
<p>在创建完socket后会为其创建一个fd描述对象,用于关联socket</p>
<p>连接创建—&gt;等待接收数据</p>
<p>5.I&#x2F;O多路复用</p>
<p>是什么</p>
<ul>
<li><p>一种用于提高服务器处理数据传输的并发处理以及提高系统资源利用率的方式</p>
</li>
<li><p>可以同时监听多个文件描述符,避免大量线程或进程阻塞等待单个I&#x2F;O的操作</p>
</li>
<li><p>能够处理大量并发连接,使得服务器能够同时处理多个客户端的请求,而不是组个处理</p>
</li>
<li><p>简化编程模型,让开发者可以通过统一的接口来管理多个I&#x2F;O操作,降低编程的复杂性,</p>
<p>无需我们实现</p>
</li>
<li><p>epoll通过事件驱动的方式唤醒线程&#x2F;进程,提高资源利用率,避免使用阻塞的方式降低性能</p>
<p>而select&#x2F;poll都会产生阻塞</p>
</li>
<li><p>单个socket的监听如 Recv,在使用多路复用之前</p>
</li>
</ul>
<p>现模型</p>
<ul>
<li><p>select(连接上限1024)</p>
</li>
<li><p>poll(无上限)</p>
</li>
<li><p>epoll(事件驱动)</p>
<ul>
<li><p>核心角色</p>
<ul>
<li><p>事件池,包含事件对象以及事件队列</p>
</li>
<li><p>Socket对象,在创建后为其关联了一个fd描述符,内部存储了读&#x2F;写缓冲区以及等待队列</p>
<p>用于管理连接的客户端,用于后续的唤醒,中断等操作</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>三者区别</p>
<p>6.TCP&#x2F;IP网络模型</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>功能参考OSI七层模型</li>
</ul>
<p>7.OSI网络七层模型</p>
<ul>
<li>应用层(客户端)</li>
<li>表示层(数据转换)</li>
<li>会话层(连接创建&#x2F;校验)</li>
<li>传输层(数据传输)</li>
<li>网络层(路由寻址)</li>
<li>数据链路层(数据打包)</li>
<li>物理层(硬件设备)</li>
</ul>
<p>8.流量整形TODO</p>
<p>9.网络通讯就是网络编程</p>
<p>10.Reactor(响应式)I&#x2F;O模型</p>
<p>它是基于NIO来实现的高性能I&#x2F;O模型</p>
<p>NIO的核心角色</p>
<ul>
<li><p>Selector ,注册器,负责管理和协调Channel</p>
</li>
<li><p>Channel,包装后的Socket对象,相当于一个高级的双向连接对象</p>
</li>
<li><p>ByteBuffer,用于缓存传输的数据</p>
</li>
<li><p>Selector和Channel的关系</p>
<blockquote>
<p>就相当于拍卖物品,首先我将物品寄放到拍卖行,告知拍卖行我的预期价格,然后等达到预期价格后,拍卖行就通知我,有符合我预期的价格了</p>
<p>在这个类比中：</p>
<ul>
<li>“物品”就相当于 Channel。</li>
<li>“拍卖行”相当于 Selector 。</li>
<li>“预期价格”相当于您为 Channel 注册到 Selector 时指定的感兴趣的事件（比如可读、可写等）。</li>
<li>“达到预期价格”相当于 Channel 上发生了您注册时指定的事件。</li>
<li>“拍卖行通知您”相当于 Selector 回调 Channel 。</li>
</ul>
</blockquote>
</li>
</ul>
<p>核心角色</p>
<ul>
<li>Reactor,负责监听和分发事件,将事件分发给对应的Handler进行处理</li>
<li>Acceptors,处理客户端连接请求,创建对应的Handler</li>
<li>Handler,异步(非阻塞)执行读写任务,处理具体业务逻辑</li>
</ul>
<p>单线程</p>
<ul>
<li>只有一个主线程负责处理连接和请求</li>
</ul>
<p>多线程(线程池)</p>
<ul>
<li>职责拆分,主线程负责处理连接,使用线程池中的线程异步处理请求</li>
</ul>
<p>主从多线程(线程池)</p>
<ul>
<li>主线程负责处理连接,将连接请分发给从线程,从线程负责请求的处理</li>
</ul>
<p>11.三种网络I&#x2F;O模型的生动描述</p>
<p>再次理解AIO,BIO,NIO 先描述一个场景 假设有一家很火的餐饮店,需要排队,有一天我到了这家店,店员告知我前面咩有空桌,需要排队等待 </p>
<p>但店员告知我有三种方案你选哪一种 </p>
<p>第一种,你先取一个号,等叫号叫到你后,我通过电话通知你,这就是AIO </p>
<p>第二种,你就在门口等着,等叫到你后,你再进去,这就是BIO </p>
<p>第三种,你取一个号,但你需要时不时过来看一看,在这期间你可以做其它的事,这是NIO </p>
<p>其中第一种和第三种方法比较类似,在等待的时间里你可以做自己的时,但一个是我主动叫你,一个是你主动查看</p>
]]></content>
  </entry>
  <entry>
    <title>网络编程协议</title>
    <url>/2024/05/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="网络编程协议"><a href="#网络编程协议" class="headerlink" title="网络编程协议"></a>网络编程协议</h2><h3 id="1-网络模型"><a href="#1-网络模型" class="headerlink" title="1.网络模型"></a>1.网络模型</h3><p>OSI网络模型</p>
<ul>
<li><p>经典七层</p>
<ul>
<li><p>应用层(Application) 客户端,比如用户使用的浏览器</p>
</li>
<li><p>表示层(Presentation) 数据的处理,转换,压缩,比如图片的从编码转换为可见的</p>
</li>
<li><p>会话层(Session) 应用的会话,用于管理会话的创建,终止,负责本地和远程的通讯及身份验证,校验等功能</p>
</li>
<li><p>传输层(Transport) 传输的方式,如TCP和UDP,还比如网络I&#x2F;O模型</p>
</li>
<li><p>网络层(Network) 用于路径的逻辑寻址,如IP</p>
</li>
<li><p>数据链路层(Data Link) 数据包装,以及安全检测,如将位数据包装成帧(打包),负责节点与节点之间的数据</p>
<p>传输</p>
</li>
<li><p>物理层(Physical) 物理设备,如网线</p>
</li>
<li><p>离下层越远,离用户越近,如应用层</p>
</li>
</ul>
</li>
</ul>
<p>TCP&#x2F;IP网络模型</p>
<p>四层</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
</ul>
<p>为什么要分层</p>
<ul>
<li>将任务进行拆分,独立的去解决每个子任务<ul>
<li>为什么要拆分</li>
<li>效率提升,职责分明</li>
<li>耦合度降低</li>
</ul>
</li>
<li>建立</li>
<li>代码复用性(重用)</li>
<li>可扩展性</li>
<li>标准化接口</li>
</ul>
<p>二者区别</p>
<p>OSI属于概念,基础,TCP则属于具体的实现,比如一个商品</p>
<h3 id="2-物理层-数据链路层"><a href="#2-物理层-数据链路层" class="headerlink" title="2.物理层+数据链路层"></a>2.物理层+数据链路层</h3><ul>
<li>硬件规格定义</li>
<li>编码和信号处理</li>
<li>数据转发</li>
<li>拓扑和物理网络设计</li>
</ul>
<p>为什么需要数据链路层</p>
<ul>
<li><p>LLC</p>
</li>
<li><p>MAC</p>
</li>
<li><p>Flow Control(传输控制)</p>
<ul>
<li><p>流量传输控制</p>
</li>
<li><p>ACK确认表示,指的是接收端在接收到完整的帧后,返回给发送端的一个确认标识</p>
</li>
<li><p>使用算法</p>
<ul>
<li><p>stop and wait 属于其中的一个最简单的算法,传输的方式是通过接收端在接收到完整的帧</p>
<p>后返回的标识,在接收到该标识后才会继续发送下一个帧,较大的帧也会拆分成多个,按照上<br>述的逻辑发送</p>
</li>
<li><p>slidingwindow 保证同一时刻有几个帧同时发送</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Error Control(故障控制)</p>
<ul>
<li>传输故障控制</li>
<li>自动重发请求协议(AQR)</li>
<li>使用算法<ul>
<li>stop and wait 和传输时的控制一致,只有在接收到接收端返回的ACK标识后,才会发送下一个帧,效率相对较低<ul>
<li>失败场景,发送过程中和接收后返回时出现问题</li>
</ul>
</li>
<li>go back  n 基于滑动窗口算法<ul>
<li>失败场景</li>
<li>返回的ACK的类型,RR(接收),RJ(拒绝)</li>
<li>Reject 当出现错误帧,会拒绝(丢弃)在这个帧及后面所有的帧,直到这个帧发送成功</li>
<li>重传帧<ul>
<li>错误帧及其后面的帧</li>
<li>错误帧(会缓存后面的帧)</li>
</ul>
</li>
<li>重传时机<ul>
<li>发送超时,接收失败,RJ(拒绝接收)</li>
<li>发送超时,SREJ(拒绝接收)</li>
</ul>
</li>
</ul>
</li>
<li>错误检测</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-帧"><a href="#3-帧" class="headerlink" title="3.帧"></a>3.帧</h3><p>结构</p>
<ul>
<li>FLAG 前后各占8bits,各1个,比特填充的首尾标志法,根据information来进行填充<ul>
<li>每5个1后补0</li>
</ul>
</li>
<li>Address 占8bits,辅助字段,用于备注接收方的地址</li>
<li>Control 8&#x2F;16bits,标识字段,用于标识该帧的类型</li>
<li>Information 可变长度,实际内容为01二进制</li>
<li>FCS 16&#x2F;32bits  帧检查序列字段</li>
<li>例子 01111110  ……   01111110</li>
</ul>
<h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h3><p>层级</p>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png"
                      alt="网络协议分层"
                ></p>
</blockquote>
<p>数据结构</p>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"
                      alt="网络协议数据结构"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E7%BB%93%E6%9E%84.png"
                      alt="网络协议抓包结构"
                ></p>
</blockquote>
<p>什么是网络</p>
<ul>
<li>网络是一组或两个或更多连接的计算设备</li>
</ul>
<p>为什么需要网络层</p>
<ul>
<li>路由 当数据包到达路由器的输入链路时.路由器会将数据包移动到输出链路</li>
<li>逻辑寻址 数据链路层实现物理寻址,网络层实现逻辑寻址,还用于区别源系统和目标系统</li>
<li>互联网络 它提供了不同类型网络之间的逻辑连接</li>
<li>分段 它是将数据包分解为不同网络传播的最小的单个数据单元的过程</li>
</ul>
<p>数据包</p>
<ul>
<li>通过Internet发送的所有数据被分解后称为数据包</li>
</ul>
<p>IP地址</p>
<ul>
<li>IP地址由4段10进制数字组成,由句点分隔开</li>
</ul>
<p>层</p>
<p>对外提供的功能,具体</p>
<p>协议</p>
<p>具体的行为,怎么做</p>
<h3 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5.传输层"></a>5.传输层</h3><p>什么是传输层</p>
<ul>
<li>提供了端到端(点对点)的方案,数据传输,建立连接的过程</li>
</ul>
<p>为什么需要传输层</p>
<ul>
<li>通讯服务 为两台主机进程之间的通行提供服务</li>
<li>处理数据包 处理数据包的顺序,数据包的错误</li>
<li>传输问题 解决传输过程中的错误</li>
</ul>
<p>TCP</p>
<ul>
<li><p>全称是Transmission Control Protocol ,他是一种通讯协议</p>
</li>
<li><p>通过该协议,数据可以通过网络完成系统之间的传输</p>
</li>
<li><p>在这种情况下,数据以数据包的形式传输,包括错误检查,以及保证数据</p>
<p>传输过程数据包的顺序问题</p>
<ul>
<li>错误检测指的是接收方对数据包的完整</li>
<li>发送方会检测接收方是否返回接收成功,决定是否重新发送</li>
</ul>
</li>
</ul>
<p>UDP</p>
<ul>
<li>不提供错误检查和数据恢复</li>
<li>并且不会因为某次发送错误停止,而是继续下次发送</li>
<li>其它的和TCP协议基本相同</li>
<li>速度相对较快,但不保证发送成功,可能会出现数据包丢失</li>
<li>适用于允许部分丢失,实时运行的场景</li>
</ul>
<p>三次握手(发送方占据主动)</p>
<ul>
<li>你吃了吗(SYN) —&gt; 发送方(请求)</li>
<li>你是问我吃了吗(SYN   ACK) —&gt; 接收方(确认)</li>
<li>是的(ACK) —&gt;发送方(确认)</li>
</ul>
<p>四次挥手(接收方占据主动)</p>
<ul>
<li>我要分手,虽然你很漂亮(SYN) —&gt; 发送方(请求)</li>
<li>林志玲表示,好的我同意分手(SYN   ACK) —&gt; 接收方(确认)</li>
<li>但是我要和你分手,不是你要和我分手(SYN) —&gt; 接收方(请求)</li>
<li>好吧,我同意(ACK) —&gt; 发送方(确认)</li>
</ul>
<h3 id="6-应用层-表示层-会话层"><a href="#6-应用层-表示层-会话层" class="headerlink" title="6.应用层+表示层+会话层"></a>6.应用层+表示层+会话层</h3><p>表示层</p>
<ul>
<li>是为通信提供了一种公共语言,以便能够进行操作,用于转换不同类型的数据</li>
</ul>
<p>会话层</p>
<ul>
<li>提供了应用建立与维持会话的服务,并且可以是会话获得同步,如SSL(安全套接字协议),TLS(安全传输层协议)</li>
</ul>
<p>应用层</p>
<ul>
<li>将主机上的数据传输到客户端上,如http(超文本传输协议),https(超文本安全传输协议)</li>
</ul>
<h3 id="7-网络传输模型数据结构"><a href="#7-网络传输模型数据结构" class="headerlink" title="7.网络传输模型数据结构"></a>7.网络传输模型数据结构</h3><p>在网络传输模型中，通常会采用类似于“<strong>header + data</strong>”的结构。</p>
<blockquote>
<p>在这种结构中，header（头部）包含了关于数据的各种信息，例如：</p>
<ol>
<li>源和目标地址；</li>
<li>数据类型；</li>
<li>长度；</li>
<li>顺序等。</li>
</ol>
<p>data（数据）则是实际要传输的信息。</p>
<p>这种结构的优点包括：</p>
<ol>
<li>提供了对数据的描述和控制信息，便于网络设备进行处理和路由选择。</li>
<li>允许不同类型的数据进行区分和识别。</li>
<li>有助于确保数据的完整性和正确性。</li>
</ol>
<p>不同的网络协议和传输模型可能会有不同的具体实现方式，但总体上都采用了类似的头部加数据的结构。</p>
</blockquote>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="1-二进制"><a href="#1-二进制" class="headerlink" title="1.二进制"></a>1.二进制</h3><p>二进制计算方式(十进制转二进制)</p>
<ul>
<li><p>取模运算,将一个数模以2,取余数,有余数为1,无余数为0,,依次往下一直计算,直到无法模2,直接赋1为最高位</p>
</li>
<li><p>减法运算,将十进制数与当前位的十进制数运算后进行比较,最高位无需运算,大于则为1,小于则为0,</p>
<p>与低位进行换算时,需减去高位,再与低位比较,计算规则同上,直到计算结果为0,剩余位补齐为0</p>
<ul>
<li>比较规则 大于等于为1,小于为0</li>
</ul>
<p>如十进制数208,转换为二进制数为11000000</p>
<p>208 &#x3D; 128+64+16</p>
<p>只计算位上数为1的值</p>
<p>1 1 0 1 0 0 0 0</p>
<ul>
<li>从高位到低位的值分别是128 64 32 16  8  4  2  1  </li>
<li>使用十进制数208与最高位比较,大于则为1,小于则为0</li>
<li>与低位进行转换时,需要减去高位,在进行比较,规则同上</li>
<li>208-128&#x3D;80,80与64进行比较,大于为1</li>
<li>再次运算80-64&#x3D;16,16小于32,小于为0</li>
<li>16无法与32进行运算,直接为0</li>
<li>16再与16进行运算,结果为0,赋为1</li>
<li>计算结果为0,不用再进行运算,剩余位补齐为0</li>
</ul>
</li>
</ul>
<p>二进制计算方式(二进制转十进制)</p>
<ul>
<li>从低位开始,以2为底,位数为幂,从0开始,直到最高位,</li>
<li><strong>2的幂次方</strong>乘以当前位数的0&#x2F;1,得出结果</li>
<li>累加得到的值就是十进制的值</li>
</ul>
<p><strong>案例</strong></p>
<p>计算二进制数10110010</p>
<ul>
<li>0 2 0 0 16 32 0 128</li>
<li>128+32+16+2</li>
<li>178</li>
<li>128 64 32 16 8 4 2 1</li>
<li>178 &gt; 128 ,大于为1</li>
<li>178-128&#x3D;50,再与64比较,小于为0</li>
<li>50 &gt; 32 ,大于为1</li>
<li>50-32&#x3D;18,再与16比较,大于为1</li>
<li>18-16&#x3D;2,再与8比较,小于为0</li>
<li>2 &lt; 4,小于为0 1011001</li>
<li>2 &#x3D; 2,等于为1</li>
<li>2-2&#x3D;0,最后结果为0,为1,并且结束运算</li>
<li>最终二进制数为10110010</li>
</ul>
<h3 id="2-八进制"><a href="#2-八进制" class="headerlink" title="2.八进制"></a>2.八进制</h3><p>计算方式和二进制一样,位数上的值乘以进制为底数的幂次方(次方为位的位置,从0开始)</p>
<p>值的表示范围0-7</p>
<ul>
<li>高位表示补齐的数(二进制数10,表示的就是2,高位表示的1表示进位后的结果,0则表示高位进行进位运算了)</li>
<li>低位表示为0,表示它的前一位数进行了进位运算</li>
<li>并且0在转换过程中是可以忽略的,无需运算</li>
<li>连续0,代表最终进位,取最终进位1的结果(最终进位的结果)</li>
<li>连续1,代表连续进位,取连续进位1的结果(连续进位的结果)</li>
<li>逢二进一,当低位结果运算结果大于1时,低位变成0,高位加1</li>
</ul>
<p>八进制中0-7的代码表示1-8</p>
<p>例子如下</p>
<p>10 表示的就是十进制的 8,以此类推,</p>
<p>11 表示的就是9,</p>
<p>12 表示的就是10</p>
<h3 id="3-十六进制"><a href="#3-十六进制" class="headerlink" title="3.十六进制"></a>3.十六进制</h3><p>计算方式同二进制类似,底数变为16的幂次方</p>
<p>值的表达范围为0-9 A-F,10在16进制用A来表示</p>
<h3 id="4-二进制运算"><a href="#4-二进制运算" class="headerlink" title="4.二进制运算"></a>4.二进制运算</h3><p>案例</p>
<p><strong>加法运算</strong></p>
<p>二进制 11+3,逢二进一</p>
<p>01011</p>
<p>00011</p>
<p>01110</p>
<p><strong>减法运算</strong></p>
<p>二进制 14-9</p>
<p>1110</p>
<p>1001</p>
<p>补码运算(时钟运算,使用溢出值得到结果)</p>
<p>二进制减法运算是把<strong>减法运算转换为加法</strong>来完成的</p>
<p>0000 1110</p>
<p>0000 1001  原码  9</p>
<p>1111  0110  反码   -118</p>
<p>1111  0111  补码   -119</p>
<p>0000 1110     加法运算</p>
<p>1111  0111</p>
<p>运算</p>
<p>1110</p>
<p>0111</p>
<p><strong>码的类型</strong></p>
<p><strong>原码</strong></p>
<ul>
<li>正常的二进制数,最高位为符号位</li>
</ul>
<p><strong>反码</strong>(取反)</p>
<ul>
<li>正数的反码就是正数,负数的反码除符号位全部取反</li>
</ul>
<p><strong>补码</strong>(先取反,后加1(最低位加1))</p>
<ul>
<li>正数的补码还是正数,负数的补码除符号位取反后加一</li>
</ul>
<p><strong>计算规则</strong></p>
<ul>
<li><p>0+1 为 1</p>
</li>
<li><p>0+0 为  0</p>
</li>
<li><p>1+1 为  10  </p>
</li>
<li><p>案例</p>
<p>1011</p>
<p>0111</p>
<ul>
<li><p>第一位 0</p>
</li>
<li><p>第二位 1 </p>
</li>
<li><p>第三位 0</p>
</li>
<li><p>第四位 0</p>
</li>
<li><p>第五位 1</p>
</li>
<li><p>顺序从右往左,结果为10010</p>
</li>
<li><p>1+1时,高位加1,低位变0</p>
<p>逢二进一,当计算结果为2时,高位就加1,低位就变为0</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Idea%E7%9A%84Debugger%E8%B0%83%E7%94%A8%E6%A0%88.png"
                      alt="Idea的Debugger调用栈"
                ></p>
</li>
</ul>
</li>
</ul>
<h3 id="5-二进制逻辑运算"><a href="#5-二进制逻辑运算" class="headerlink" title="5.二进制逻辑运算"></a>5.二进制逻辑运算</h3><p>false(0)  true(1)</p>
<p>一对值</p>
<ul>
<li>逻辑与(AND)    相同取对应值0&#x2F;1,不同取0,满足所有条件时才成立,可达到类似取模的效果,并且可以得到一个特定范围的值(范围为0-被除数这个区间内)</li>
<li>逻辑或(OR)    相同取对应值0&#x2F;1,不同取1,任意条件满足都成立</li>
</ul>
<p>单个值</p>
<ul>
<li>逻辑非(NOT) 取反,0取1,1取0</li>
</ul>
<p>取反值</p>
<ul>
<li>逻辑异或(XOR) 二者相同时取0,不同时取1(适用于查找,找不同)</li>
<li>逻辑同或(XNOR) 二者相同时取1,不同时取0</li>
</ul>
<p>5.取模,取余运算</p>
<p>计算结果都为最后的余数,取的都是被能够整除后的余数</p>
<p>区别</p>
<ul>
<li><p>取模,除数为负,余数就为负</p>
</li>
<li><p>取余,被除数为负,余数就为负</p>
</li>
<li><p>例如 5%2,此时5为被除数.2为除数</p>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E5%8F%96%E6%A8%A1%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%E5%B7%AE%E5%BC%82.png"
                      alt="取模取余运算差异"
                ></p>
</blockquote>
</li>
</ul>
<h3 id="6-进制转换公式"><a href="#6-进制转换公式" class="headerlink" title="6.进制转换公式"></a>6.进制转换公式</h3><ul>
<li><p>转换</p>
<p>被除数 &#x3D; 商*除数+余数</p>
<p>商&#x3D;初始值&#x2F;除数(进制)</p>
<p>商作为下次被除数与除数参与运算,直到无法整除结束</p>
</li>
<li><p>计算</p>
<p>总值 &#x3D; 进制的幂次方(当前位的下标) * 位值(当前位上的值)+… 依次加上后续位的计算结果(也就是进制的幂次方乘以位上的值)</p>
</li>
</ul>
<h3 id="7-计算方式结果叫法"><a href="#7-计算方式结果叫法" class="headerlink" title="7.计算方式结果叫法"></a>7.计算方式结果叫法</h3><ul>
<li>加法运算结果称为和</li>
<li>减法运算结果称为差</li>
<li>乘法运算结果称为积</li>
<li>除法运算结果称为商</li>
</ul>
<h3 id="8-位移运算符"><a href="#8-位移运算符" class="headerlink" title="8.位移运算符"></a>8.位移运算符</h3><ul>
<li><p>左移(&lt;&lt;),左移几位,高位就丢弃几位</p>
<p>例,如下,左移1位</p>
<p>01110</p>
<p>11100</p>
</li>
<li><p>右移,右移几位,高位就补齐几位</p>
<ul>
<li>无符号右移(&gt;&gt;&gt;),正数,高位补0,负数,高位补1</li>
<li>右移(&gt;&gt;),不管正数,负数,都在高位补0</li>
</ul>
<p>例,右移1位</p>
<p>11110  源</p>
<p>01111  右移</p>
<p>11111  无符号右移</p>
</li>
<li><p>总结</p>
<ul>
<li>左乘右除,左边位移几位,就是乘以2的幂次方(幂为位移的个数)</li>
<li>右移则是除以2的幂次方(幂为位移的个数)</li>
</ul>
</li>
</ul>
<h2 id="网络编程应用场景"><a href="#网络编程应用场景" class="headerlink" title="网络编程应用场景"></a>网络编程应用场景</h2><h3 id="1-IP"><a href="#1-IP" class="headerlink" title="1.IP"></a>1.IP</h3><p>什么是IP</p>
<ul>
<li>是一个使用四组数字构成的地址,中间用句点分隔<ul>
<li>每组数字又是一个8位的二进制数值</li>
<li>最大显示为255,在使用时需要转换为二进制给计算机使用</li>
<li>255.255.255.0</li>
</ul>
</li>
<li>它被分配给网络设备的网络接口卡(网卡)</li>
<li>分为两部分,分别是网络部分(整体,如某某市,区,街道)和主机部分(个体,如门牌号,具体地址)</li>
</ul>
<p>怎么使用IP</p>
<ul>
<li><p>网络地址</p>
<ul>
<li><p>非具体,更像指向某一个区域,被称为网络前缀</p>
<blockquote>
<ul>
<li><p>203.0.113.0</p>
</li>
<li><p>最后一组数值为主机地址,前三组为网络地址</p>
</li>
<li><p>最后一组数值为0时,转换为2进制为00000000,</p>
</li>
</ul>
<p> 代表该地址为网络地址</p>
<ul>
<li>不能将这个地址分配给网卡所使用</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>广播地址</p>
<ul>
<li><p>群发,所有设备的通用标识符,类似于邮箱,大家都会使用</p>
<blockquote>
<ul>
<li><p>203.0.113.255</p>
</li>
<li><p>最后一组数值为255时,转换为2进制为11111111,</p>
</li>
</ul>
<p> 代表该地址为广播地址</p>
</blockquote>
</li>
</ul>
</li>
<li><p>主机地址</p>
<ul>
<li><p>具体地址,指向某台特定设备,主机</p>
<blockquote>
<ul>
<li><p>203.0.113.10</p>
</li>
<li><p>最后一组数值(子网掩码)不为0或255时,假设是10,转换为2进制为00001010,</p>
</li>
</ul>
<p> 代表该地址为主机地址,可以分配给硬件设备,如一台打印机</p>
<ul>
<li>可使用范围为1-254</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>私有地址</p>
<ul>
<li><p>只允许公司内部使用(不可再公网暴露)</p>
<blockquote>
<ul>
<li>10.0.0.0 —  10.255.255.255</li>
<li>172.16.0.0 — 172.16.255.255</li>
<li>192.168.0.0 — 192.168.255.255</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>IP类型数据报(打包后的数据包裹)Header的构成</p>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Ip%E5%8D%8F%E8%AE%AEHeader%E7%BB%93%E6%9E%84.png"
                      alt="Ip协议Header结构"
                ></p>
<ul>
<li>一行占32bit</li>
<li>Vesion IP协议版本好,占4bit,如IPV6,版本号显示为6</li>
<li>IHL Internet Head Length,表示网络头部长度,占4bit</li>
<li>Type of Service,表示服务的类型,决定传输的性能优劣,占8bit</li>
<li>Total Length,表示Head和数据的总长度,占16bit</li>
<li>Identification,表示的一个标识,用于标识一个唯一数据包,占16bit</li>
<li>Flags 表示一个标记,占3bit</li>
<li>Fragment Offset 表示片的偏移量,占13bit</li>
<li>Time to LIve 表示数据包的存活时间,以秒计算,占8bit</li>
<li>Protocol 表示下一个层级的协议,占8bit</li>
<li>Header Checksum 表示头的错误检测,占16bit</li>
<li>Source Address 表述源地址(源ip),占32bit</li>
<li>Destination Address 表示目标地址(目标ip),占32bit</li>
<li>Options 表示选项,可变的参数,如传输数据的编码格式,占</li>
<li>Padding 表示数据包头的长度一定是32的倍数</li>
<li>Data 表示具体的数据</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>人类可识别的 如ABCD,这种都属于符号</p>
<p>再将其转换为特定编码,转换为特定的数值</p>
<p>再将其转换为计算机可失败的二进制数值</p>
</blockquote>
<h3 id="2-IP地址组成及分类"><a href="#2-IP地址组成及分类" class="headerlink" title="2.IP地址组成及分类"></a>2.IP地址组成及分类</h3><ul>
<li>类型及表示范围(ABCDE)1981年</li>
</ul>
<blockquote>
<ul>
<li>A<ul>
<li>0.0.0.0 — 127.255.255.255</li>
<li><strong>10</strong>.0.10.0</li>
<li>前8位(第一组数值)为网络地址,后24位(后三组数值)为主机地址</li>
</ul>
</li>
<li>B<ul>
<li>128.0.0.0 — 191.255.255.255</li>
<li><strong>172</strong>.<strong>16</strong>.10.10</li>
<li>前16位(前两组数值)为网络地址,后8位(后两组数值)为主机地址</li>
</ul>
</li>
<li>C<ul>
<li>192.0.0.0 — 223.255.255.255</li>
<li><strong>192</strong>.<strong>168</strong>.<strong>0</strong>.10</li>
<li>前24位(前三组数值)为网络地址,后8位(后一组数值)为主机地址</li>
<li>可用网络地址计算<ul>
<li>223-192+1(起始地址) &#x3D; 32  代表32种可能,从192到223</li>
<li>每个网络地址都可以包含254个可用主机地址,已经去除2个不能分配的地址,<br>0和255,分别是网络地址和广播地址</li>
</ul>
</li>
</ul>
</li>
<li>D<ul>
<li>224.0.0.0 — 239.255.255.255</li>
<li><strong>224</strong>.<strong>0</strong>.<strong>0</strong>.<strong>6</strong></li>
<li>全部为网络地址</li>
<li>一般用于广播</li>
</ul>
</li>
<li>E<ul>
<li>240.0.0.0  — 255.255.255.255</li>
<li>一般用于实验</li>
</ul>
</li>
<li>为什么说ABCDE分类比较浪费<ul>
<li>适用于一个IP使用量比较大的公司</li>
<li>假设我们有500ip地址,但c级无法满足,需要使用b级,但b级的范围太广了,造成了浪费</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>类型及表示范围(无类寻址)1995年</p>
<blockquote>
<ul>
<li><p><strong>203</strong>.<strong>0</strong>.<strong>113</strong>.10</p>
</li>
<li><p>前24位为网络地址,后8位为主机地址</p>
</li>
<li><p>通过子网掩码的方式告知我们哪个部分是网络地址(寻址部分),哪个部分是主机地址</p>
<p>在宿主部分的位置用零来告知,如255.0.0.0.或255.255.225.0</p>
</li>
<li><p>0的起始位置就是主机地址</p>
</li>
</ul>
</blockquote>
</li>
<li><p>子网掩码</p>
<blockquote>
<ul>
<li><p>255.255.255.0</p>
</li>
<li><p>每多一个字节来显示0,代表主机地址组合增加</p>
</li>
<li><p>作为网络地址和主机地址的分界</p>
</li>
<li><p>需把子网掩码数值转换为二进制后的位,作为分界的规则</p>
<p>如掩码的位数为22时,从第22位后,就作为主机地址了,22位<br>之前就都是网络地址了</p>
</li>
<li><p>通过子网掩码的方式,决定哪部分是寻址部分(网络地址)</p>
</li>
<li><p>缓解IPV4的一部分压力</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="3-IPV6"><a href="#3-IPV6" class="headerlink" title="3.IPV6"></a>3.IPV6</h3><p>为什么</p>
<p>原有的IPV4,因为历史的原因,随着使用量的增加,剩余的可使用ip越来越少,所以<br>产生了IPV6,于1996年诞生</p>
<p>怎么做</p>
<ul>
<li>IPV4和IPV6不同点</li>
</ul>
<blockquote>
<ul>
<li><p>大小方面</p>
<ul>
<li>IPV4   32位的表达范围</li>
<li>IPV6  128位的表达范围</li>
</ul>
</li>
<li><p>分组方面</p>
<ul>
<li>IPV4 分为4组数值</li>
<li>IPV6 分为8组数值</li>
</ul>
</li>
<li><p>网络地址</p>
<ul>
<li>IPV4 根据类型或子网掩码区分网络地址部分</li>
<li>IPV6 前四组数值为网络地址部分</li>
</ul>
</li>
<li><p>表示</p>
<ul>
<li>IPV4  203.0.123.10</li>
<li>FC00:0000:130F:0000:0000:09C0:876A:130B</li>
</ul>
</li>
<li><p>大小</p>
<ul>
<li><p>IPV6,每组用16进制表示,数值最大为四位,每位16进制数转换为2进制后,</p>
<p>需要用四位二进制数表示,一组则需要16位,总共8组,共128位</p>
</li>
<li><p>IPV4,每组用10进制表示,最大的数值为255,转换2进制后,需用8位来表示</p>
<p>总共四组,共32位</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>表示</p>
<blockquote>
<ul>
<li><p>IPv6地址总长度为128比特，通常分为8组，每组为4个十六进制数的形式，每组十六进制数间用冒号分隔。例如：FC00:0000:130F:0000:0000:09C0:876A:130B，这是IPv6地址的首选格式</p>
</li>
<li><p>为了书写方便，IPv6还提供了压缩格式，以上述IPv6地址为例，具体压缩规则为：</p>
<ul>
<li><p>每组中的前导“0”都可以省略，所以上述地址可写为：FC00:0:130F:0:0:9C0:876A:130B。</p>
</li>
<li><p>地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替，所以上述地址又可以进一步简写为：FC00:0:130F::9C0:876A:130B。</p>
</li>
</ul>
<p> 说明：<br> 需要注意的是，在一个IPv6地址中只能使用一次双冒号“::”，<br> 否则当计算机将压缩后的地址恢复成128位时，无法确定每个“::”代表0的个数</p>
</li>
</ul>
</blockquote>
</li>
<li><p>访问</p>
<blockquote>
<ul>
<li>一般只有在相同网段(网络地址)的ip才能相互访问</li>
<li>可以通过设置路由表或修改到相同网段下,就可以互相访问了</li>
</ul>
</blockquote>
</li>
<li><p>地址类型</p>
<blockquote>
<ul>
<li><p>单播地址 - 用于本地通讯</p>
</li>
<li><p>全球单播地址</p>
</li>
<li><p>链路本地地址 - 用于本地通讯,格式必须是FE80::&#x2F;10</p>
</li>
<li><p>环回地址 -    ::1&#x2F;128(对应IPV4的127.0.0.1)</p>
</li>
<li><p>未指定地址 ::&#x2F;128</p>
</li>
<li><p>唯一本地地址-不可和公共网络交流(IPV4可以)</p>
</li>
<li><p>组播地址-用于一对多的通讯,可针对某组,IPV4则不行</p>
</li>
<li><p>任播地址-用于将一个地址赋给多台主机,一般不允许使用</p>
</li>
</ul>
</blockquote>
<p>是什么</p>
<ul>
<li>是一组能够在茫茫网络中寻找主机的地址</li>
</ul>
</li>
</ul>
<h3 id="4-IP子网框架"><a href="#4-IP子网框架" class="headerlink" title="4.IP子网框架"></a>4.IP子网框架</h3><ul>
<li><p>为什么</p>
<ul>
<li>为了得到一个更小的网络单位,通过限定位数的方式来达到拆分的效果</li>
</ul>
</li>
<li><p>怎么做</p>
<blockquote>
<p>案例</p>
<ul>
<li>203.0.13这么一个网络地址,我们想要分配一个0到31范围的主机地址</li>
<li>可以通过限定网络地址的位数以及起始IP</li>
<li>如203.0.13.0&#x2F;27 ,0代表起始IP,27代表网络地址位数</li>
<li>正常的网络地址位数为24,多了3位则代表限定了起始IP</li>
</ul>
</blockquote>
</li>
<li><p>是什么</p>
<ul>
<li>通过限定一定位数,达到网段的划分</li>
</ul>
</li>
</ul>
<h3 id="5-路由器工作原理-IP路由"><a href="#5-路由器工作原理-IP路由" class="headerlink" title="5.路由器工作原理(IP路由)"></a>5.路由器工作原理(IP路由)</h3><ul>
<li>为什么<ul>
<li>不同网络下的主机需要互相连接,需要通过路由器这个中转的角色来完成|<br>相互记录</li>
</ul>
</li>
<li>怎么做<ul>
<li>路由器通过路由表记录当前目的地与下一个目的地</li>
<li>通过记录目标ip与下一个ip,通过下一个ip再找到下一个ip</li>
<li>通过这条路径来寻找到最终的目的地</li>
<li>root—&gt;目标ip—&gt;下一个ip—&gt;下一个ip</li>
</ul>
</li>
</ul>
<h3 id="6-TCP-数据传输"><a href="#6-TCP-数据传输" class="headerlink" title="6.TCP(数据传输)"></a>6.TCP(数据传输)</h3><ul>
<li><p>为什么</p>
<ul>
<li>主机事务数据需要传输</li>
</ul>
</li>
<li><p>怎么做</p>
<ul>
<li><p>三次握手,四次挥手(建立连接的流程与断开连接的流程)</p>
<ul>
<li>大部分场景下断开连接的操作是由发送方完成的,<br>在某些情况下,接收方也会主动断开,具体情况可能<br>和web服务器的具体实现相关</li>
</ul>
</li>
<li><p>连接重置(Reset,发送方和接收方都可以执行该操作)</p>
<ul>
<li>数据传输的过程中被安全设施发现数据不太安全,接收方<br>将会重置该TCP连接</li>
</ul>
</li>
<li><p>端口号</p>
<ul>
<li><p>可使用范围0-65535</p>
</li>
<li><p>分类</p>
<ul>
<li><p>公认,指的是历史上,经过考验并长期使用的端口号,范围是0-1023</p>
<ul>
<li><p>比较常用的有Http的80,Https的443,Ssh的22,Ftp的20&#x2F;21,Telent的</p>
<p>23</p>
</li>
</ul>
</li>
<li><p>注册,指的是特定某个官方去组织里注册的端口号,合规,范围是1024-49191</p>
</li>
<li><p>临时,指的是未去注册的端口号,仅临时使用,范围是49192-65535</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>协议数据单元(数据传输时的结构&#x2F;数据结构) Segment(包含头Header和数据段data)</p>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Tcp%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83.png"
                      alt="Tcp协议数据单元"
                ></p>
</blockquote>
<ul>
<li>Source Port  源端口号 </li>
<li>Destination Port 目标端口号 </li>
<li>Flags 请求标识<ul>
<li>SYN</li>
<li>SYN-ACK</li>
<li>ACK</li>
<li>FIN</li>
<li>FIN-ACK</li>
<li>RST</li>
<li>URG</li>
</ul>
</li>
<li>Seq# 序列号</li>
<li>Ack# 确认序列号</li>
<li>Payload 负载,实际传输的数据(侧重于数据本身)</li>
</ul>
</li>
<li><p>Packet(数据包)</p>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Tcp%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8C%85.png"
                      alt="Tcp协议数据包"
                ></p>
</blockquote>
<ul>
<li><p>Segment属于数据包所拆分出的一部分</p>
</li>
<li><p>然后将Packet作为Frame的一部分,然后发送到服务端</p>
</li>
<li><p>服务器端会向剥开洋葱一样,一层一层剥开,把Packet从Frame中取出</p>
</li>
<li><p>在把Segmen从Packet中剥离出,再做类似的动作将新的Segment和Packet包装成新的Frame返回</p>
<p>给客户端</p>
</li>
<li><p>客户端发送数据–&gt;打包–&gt;成为Frame(数据包)—&gt;经过网络中的路由器路由到真正的主机后</p>
<p>—&gt;服务端取出里面的包裹Packet—&gt;再取出包裹里的Segment—&gt;服务端经过处理后生成新的Packet和Segment</p>
<p>包装成新的Frame返回给客户端</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>是什么</p>
<ul>
<li>它的全称是Transmission Control Protocol</li>
<li>这个协议的目的是通过创建Session的方式,来完成数据传输</li>
</ul>
</li>
</ul>
<h3 id="7-TCP-数据传输流程"><a href="#7-TCP-数据传输流程" class="headerlink" title="7.TCP(数据传输流程)"></a>7.TCP(数据传输流程)</h3><p><strong>传输层链接过程中需要三次握手,四次挥手</strong></p>
<p>层级从<strong>低</strong>到<strong>高</strong></p>
<p>分别是从物理层到数据链路层,再到到网络层,再到传输层,再到应用层的<br>数据结构</p>
<p>Bit—&gt;Frame—&gt;Packet—&gt;Segment—&gt;Data</p>
<p>服务端</p>
<blockquote>
<ul>
<li><p>服务端在接收到请求后,拨开Packet,拿到Segment</p>
</li>
<li><p>修改Seq(数据开始的字节,从这里开始发送)为1,Ack(确认收到的字节)为1</p>
</li>
</ul>
<p> payload则放入需要传输的数据.图片(假设此时图片较大,需要分片发送)</p>
<ul>
<li><p>seq默认为0,ack默认为1,payload最大能够存放1450byte</p>
</li>
<li><p>修改完成后,将其放入Packet(包裹),打包返回Frame(数据包)给客户端</p>
</li>
</ul>
</blockquote>
<p>客户端</p>
<blockquote>
<ul>
<li><p>客户端在接收完数据包后,解析其中的segment</p>
</li>
<li><p>接收完成后,修改Seq为1(因为客户端未发送数据,修改为1),ACK则修改为1251</p>
<p>代表接收到1250个字节的数据,下次则从这里再次发送</p>
</li>
<li><p>修改完数据段后,进行打包,返回数据包给服务端</p>
</li>
<li><p>循环往复,直到全部接收完成</p>
</li>
</ul>
</blockquote>
<p>传输遇到问题</p>
<ul>
<li><p>如何解决(数据未接收到)</p>
<ul>
<li><p>重试</p>
</li>
<li><p>客户端告知哪些部分未收到(发送给服务端一个特殊的Segment),里面的flags为SACK,Seq为1,Ack为上次接收的字节数上加1(如5001),和丢失的范围 (如2501-3750),服务端将这些数据重新打包后再发送</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-UDP-数据传输"><a href="#8-UDP-数据传输" class="headerlink" title="8.UDP(数据传输)"></a>8.UDP(数据传输)</h3><ul>
<li>使用什么协议由客户决定,看其选择效率还是稳定</li>
</ul>
<blockquote>
<p>使用TCP协议</p>
<ul>
<li>传输(超文本传输协议)<ul>
<li>HTTP,HTTPS</li>
</ul>
</li>
<li>会话<ul>
<li>Telnet,SSH,FTP,SFTP</li>
</ul>
</li>
<li>邮件<ul>
<li>POP,IMAP,SMTP</li>
</ul>
</li>
</ul>
<p>使用UDP协议</p>
<ul>
<li>解析<ul>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li>传输(纯粹使用UDP)<ul>
<li>TFTP 传输小的文件(一个简单的传输)</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>UDP header结构<ul>
<li>source port(源端口) 占16bit</li>
<li>destination port(目标端口) 占16bit</li>
<li>length 占16bit</li>
<li>checksum 占16bit</li>
</ul>
</li>
</ul>
<h3 id="9-数据包和数据报侧重方面"><a href="#9-数据包和数据报侧重方面" class="headerlink" title="9.数据包和数据报侧重方面"></a>9.数据包和数据报侧重方面</h3><p>数据包侧重于结构方面,数据报则更侧重于传输方面</p>
<p>数据包通常强调以下方面：</p>
<ol>
<li><strong>结构和格式</strong>：包括头部信息、数据部分等。</li>
<li><strong>封装和标识</strong>：明确数据源和目标。</li>
<li><strong>完整性和一致性</strong>：确保数据在传输过程中不丢失或损坏。</li>
</ol>
<p>数据报则更侧重于：</p>
<ol>
<li><strong>传输过程</strong>：如何在网络中<a class="link"   href="coco://sendMessage?ext={" s%24wiki_link"%3A"https%3A%2F%2Fm.baike.com%2Fwikiid%2F2129442810616176116"}&msg=路由">路由 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和传递。</li>
<li><strong>实时性</strong>：满足某些应用对实时性的要求。</li>
<li><strong>效率和性能</strong>：优化传输速度和资源利用。</li>
</ol>
<p>然而，这两个概念在实际应用中并非完全割裂。</p>
<p>数据包的结构设计也会影响传输性能，而数据报的传输方式也需要遵循一定的结构规范。</p>
<p>在不同的场景中，可能会根据具体需求强调数据包或数据报的某些方面。</p>
<p>例如，在一些对数据完整性和准确性要求较高的场景中，可能更关注数据包的结构；而在一些实时性要求较高的场景中，可能更侧重数据报的传输效率。</p>
<p>总之，数据包和数据报的侧重点可能因应用场景和需求的不同而有所差异，但它们相互关联，共同确保数据在网络中的有效传输。</p>
<h3 id="10-TCP拥塞模型–需要再次学习"><a href="#10-TCP拥塞模型–需要再次学习" class="headerlink" title="10.TCP拥塞模型–需要再次学习"></a>10.TCP拥塞模型–需要再次学习</h3><p>提高网络带宽的使用效率</p>
<p>为什么</p>
<ul>
<li>提高网络性能</li>
<li>增强可靠性</li>
<li>公平性</li>
<li>使用性</li>
<li>稳定性</li>
<li>优化资源利用</li>
</ul>
<p>怎么做</p>
<ul>
<li>拥塞窗口</li>
<li>拥塞算法</li>
<li>慢启动</li>
<li>快速启动</li>
<li>拥塞检测机制<ul>
<li>一种是丢包</li>
<li>另一种是是测量延时</li>
</ul>
</li>
</ul>
<p>什么是Mss</p>
<p>是什么</p>
<ul>
<li>一种帮助TCP高效稳定的利用网络资源传输的策略(行为)<br>这种行为下的执行效率更高</li>
</ul>
<h3 id="11-NetStat命令"><a href="#11-NetStat命令" class="headerlink" title="11.NetStat命令"></a>11.NetStat命令</h3><p>查看主机上的TCP连接对应的端口及IP地址的信息</p>
<p>前置知识</p>
<ul>
<li>全双工,指的是在通信过程中,数据可以同时在两个方向进行数据的传输<br>与之相对的是半双工,它只能在一个时间点内进行单向的数据传输</li>
<li>状态切换,连接的状态变换</li>
</ul>
<p>命令执行</p>
<ul>
<li>-n  快照</li>
<li>-n 1 每秒刷新</li>
<li>-na 查看所有的连接,TCP&#x2F;UDP连接 </li>
<li>-nap TCP 查看TCP的连接</li>
<li>-R 查看路由表信息</li>
</ul>
<h3 id="12-HTTP"><a href="#12-HTTP" class="headerlink" title="12.HTTP"></a>12.HTTP</h3><p>是什么</p>
<ul>
<li>http是一个简单的请求-响应协议,通常运行在TCP之上,它指定了客户端<br>可能发送给服务器什么样的消息以及得到什么样的响应结果</li>
<li>为了将超文本标记语言(HTML)文档从web服务器传输到客户端的浏览器</li>
<li>它定义了与服务端的交互逻辑与方式.实现客户端与服务端的交互</li>
</ul>
<p>怎么做</p>
<ul>
<li><p>分类</p>
<ul>
<li><p>http 0.9 —&gt;1991</p>
</li>
<li><p>http 1.0 —&gt;1996</p>
</li>
<li><p>http 1.1 —&gt;1999</p>
<ul>
<li><p>提供了更多选择的缓存头来控制缓存策略</p>
</li>
<li><p>带宽优化及网络连接使用</p>
</li>
<li><p>Host处理,在Http1.0中认为每台服务器都绑定一个唯一的ip地址</p>
</li>
<li><p>长连接优化,有一个叫做Connection的信息,默认设置为keep-alive.</p>
<p>对于Tcp的连接复用,用一个TCP连接完成多次传输复用</p>
</li>
<li><p>错误通知管理</p>
<ul>
<li><p>200,客户端请求资源</p>
<ul>
<li>200 请求资源ok,返回成功</li>
<li>201 创建资源ok,返回成功</li>
</ul>
</li>
<li><p>400</p>
<ul>
<li><p>400 客户端请求语法错误,服务器无法理解</p>
</li>
<li><p>401 请求要求用户需要身份认证</p>
</li>
<li><p>403 服务器理解客户端请求,但拒绝执行该请求</p>
</li>
<li><p>404 服务器无法根据客户端的请求找到资源(网页)</p>
<p>网站设计人员可设置请求资源无法找到的个性页面</p>
</li>
</ul>
</li>
<li><p>500</p>
<ul>
<li>500 服务器内部错误,无法处理请求</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>http 2 —&gt;2015</p>
</li>
</ul>
</li>
</ul>
<p>为什么</p>
<ul>
<li><p>尼尔森定律,以一定的规律线性增长</p>
</li>
<li><p>带宽,它是在被用来描述信道时,能够有效通过信道的信号最大频带宽度</p>
<p>如现实中某个水管能够通过的最大的流量,电线能够通过的最大电流,<br>高速公路能够运行的车辆数量</p>
</li>
<li><p>延迟,它则是在传输介质中所用传输的时间,即从报文进入到离开网络的所</p>
<p>消耗的时间,和网络使用情况相关</p>
</li>
<li><p>资源加载和带宽的关系,网页加载延迟消耗时间</p>
</li>
<li><p>随着时间增长,网页加载所需的资源越来越多</p>
</li>
</ul>
<p>http1版本的缺点</p>
<ul>
<li>队头阻塞<ul>
<li>后面发起的请求会被之前未处理的请求阻塞住</li>
</ul>
</li>
<li>流量控制<ul>
<li>无法保证客户端与服务端传输速率的动态调整,造成带宽浪费,性能降低</li>
</ul>
</li>
</ul>
<p>SPDY(Goole提出的一种解决方案,Http2的前身)</p>
<ul>
<li>降低延迟</li>
<li>请求优先级</li>
<li>Header压缩</li>
<li>基于Https的加密协议传输</li>
<li>服务端推送</li>
</ul>
<p>Http2</p>
<ul>
<li><p>1 传输的内容是明文</p>
</li>
<li><p>2 传输的内容则是二进制,但传输的内容和1是一致的</p>
</li>
<li><p>向下兼容(<strong>H2C</strong>),为了http1可以在http2的环境下可以继续使用,</p>
<p>http2提供了向下兼容的解决方案,通过在请求前发送一个升级包</p>
<p>会返回一个101.表示更换协议,升级连接</p>
<p>如果不支持,则会返回200,或404的状态码</p>
</li>
</ul>
<p>12.Http和Https区别</p>
<ul>
<li>开头</li>
<li>安全</li>
<li>端口</li>
<li>相关层</li>
<li>证书</li>
<li>加密</li>
<li>Https可以有效防止运营商劫持,解决了防止劫持的问题</li>
</ul>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Http%E4%B8%8EHttps%E5%8C%BA%E5%88%AB.png"
                      alt="Http与Https区别"
                ></p>
</blockquote>
<h3 id="13-HTTP2"><a href="#13-HTTP2" class="headerlink" title="13.HTTP2"></a>13.HTTP2</h3><p>优点</p>
<ul>
<li><p>多向请求和响应</p>
</li>
<li><p>TCP连接多路复用</p>
<ul>
<li>TCP拥塞机制</li>
<li>数据流复用一个连接</li>
</ul>
</li>
<li><p>请求优先级</p>
<ul>
<li>优先加载必要资源</li>
</ul>
</li>
<li><p>每个来源一个连接</p>
</li>
<li><p>流量控制</p>
</li>
<li><p>头压缩</p>
</li>
<li><p>缺点</p>
<ul>
<li>多路复用所带来的问题</li>
<li>依赖于TCP相关机制</li>
</ul>
</li>
</ul>
<h3 id="14-HTTPS"><a href="#14-HTTPS" class="headerlink" title="14.HTTPS"></a>14.HTTPS</h3><p>安全的超文本传输协议</p>
<p>CA证书</p>
<ul>
<li>由特定单位颁发的安全证书</li>
<li>加入可信(计算机)</li>
<li>敏感且重要</li>
</ul>
<p>SSL(安全套接字)</p>
<p>TLS(SSL的接任者)</p>
<blockquote>
<p>TLS握手流程</p>
<ul>
<li>客户端先开始握手流程</li>
<li>将其支持的最高解绑TLS和其他信息一起发送给服务端</li>
</ul>
</blockquote>
<h3 id="15-DNS-域名解析"><a href="#15-DNS-域名解析" class="headerlink" title="15.DNS(域名解析)"></a>15.DNS(域名解析)</h3><p>将域名翻译为主机的实际IP地址</p>
<p>host文件</p>
<ul>
<li>存储ip地址和域名映射关系的文件,DNS就是类似该文件</li>
</ul>
<p>DNS解析流程</p>
<ul>
<li><p>本地文件—&gt;DNS缓存—&gt;DNS服务器</p>
</li>
<li><p>首先尝试检查本地计算机查找,然后查找不到的话,再尝试去DNS缓存(本地的)中查找<br>最后才会去DNS服务器上查找,解析,实在查找不到才会去DNS服务器</p>
</li>
<li><p>本地计算机存储映射关系的文件一般叫做主机文件</p>
</li>
<li><p>windos的文件为hosts,路径一般为 c:\windows\System32\drivers\etc\hosts</p>
</li>
<li><p>linux的文件为hosts, 路径一般为 &#x2F;etc&#x2F;hosts</p>
</li>
<li><p>本地找不到,去DNS服务器去找,当前服务器找不到就会将其传递给下一个DNS服务器</p>
<p>流程是<strong>根服务器</strong>—&gt;<strong>顶级服务器</strong>—&gt;<strong>权威服务器</strong>,根服务器和顶级服务器不会直接返回</p>
<p>实际主机地址,而是返回它俩的下级,也就是顶级和权威的主机地址,只有权威服务器会</p>
<p>返回真正的主机地址.然后将其缓存到本地的DNS缓存中</p>
</li>
</ul>
<p>权威和非权威的回应</p>
<ul>
<li><p>ZONE,加入你有一个和DNS服务器相同的域名,如test.com,就代表它们处在一个相同的网络区域</p>
<p>也就是ZONE,可以通过该DNS服务查出 test.com相关的所有主机</p>
</li>
<li><p>直接从该DNS服务器查询出的结果就代表为最权威的.是最可信的</p>
</li>
<li><p>而非权威则相反,通过不断询问,这个结果可能是其他的区域(ZONE)返回的,所以不太权威</p>
</li>
</ul>
<p>DNS结构</p>
<ul>
<li>Root 最高的DNS级别,一个有13个,如.com  .net ,也被称为Top Level Domain</li>
<li>Second 第二级别,如  xxx.com,xxx则代表二级域名</li>
<li>ICANN(Internet Corporation for Assigned Names),专门负责管理顶级域名分配的服务器,<br>负责完成大部分TLD的分配,它也被叫做TLD服务器</li>
</ul>
<p>DNS Zone查找方式???(具体是什么)</p>
<ul>
<li><p>正向查找 通过hostname去查找ip,你给我hostname,我去帮你查找ip</p>
</li>
<li><p>泛型查找 通过ip去查找对应hostname,一般用于邮件服务器验证这个源域名</p>
<p>是否来自合法的域名</p>
</li>
</ul>
<p>DNS Zone type(区域类型) ???分别是什么</p>
<ul>
<li>Primary Zone(主区域)<ul>
<li>权威的区域信息</li>
<li>具有区域数据的读&#x2F;写副本</li>
<li>接收来自客户端的动态更新或动态DNS</li>
</ul>
</li>
<li>Second Zone(次要区域)</li>
<li>Zone Transfer DNS 传输区域</li>
</ul>
<p>缓存DNS服务器 是什么 ???</p>
<p>资源记录 是什么??? 域名和主机地址</p>
<ul>
<li>普通资源记录</li>
<li>特殊资源记录</li>
</ul>
<h3 id="16-NAT-网络控制"><a href="#16-NAT-网络控制" class="headerlink" title="16.NAT(网络控制)"></a>16.NAT(网络控制)</h3><p>因为internet爆炸性的增长导致ip地址空间耗尽,然后nat产生了</p>
<h3 id="17-SMTP-邮件"><a href="#17-SMTP-邮件" class="headerlink" title="17.SMTP(邮件)"></a>17.SMTP(邮件)</h3><h3 id="18-VPN-代理"><a href="#18-VPN-代理" class="headerlink" title="18.VPN(代理)"></a>18.VPN(代理)</h3><h3 id="19-SSH-远程连接"><a href="#19-SSH-远程连接" class="headerlink" title="19.SSH(远程连接)"></a>19.SSH(远程连接)</h3><h3 id="n-TCP-IP协议总结"><a href="#n-TCP-IP协议总结" class="headerlink" title="n.TCP&#x2F;IP协议总结"></a>n.TCP&#x2F;IP协议总结</h3><p>TCP&#x2F;IP 协议栈的每一层都是使用下层的基础,并且在其基础上进行增强</p>
<p>底层相对<strong>抽象</strong>,高层在<strong>依赖抽象</strong>的基础上对其使用并增强</p>
<p>这种分层设计具有以下优点：</p>
<ol>
<li><strong>模块化</strong>：每一层都可以独立设计、实现和维护。</li>
<li><strong>可扩展性</strong>：新的功能可以在适当的层添加，而不影响其他层。</li>
<li><strong>灵活性</strong>：不同的应用可以根据需要选择使用协议栈的不同层次。</li>
<li><strong>易于理解和调试</strong>：分层使得复杂的网络通信过程更易于分析和处理。</li>
</ol>
<p>下层提供的服务为上层提供了基础，上层在此基础上进行增强和扩展：</p>
<ol>
<li><strong>网络接口层</strong>：提供物理连接和数据传输功能。</li>
<li><strong>IP 层</strong>：实现网络寻址和数据包<a class="link"   href="coco://sendMessage?ext={" s%24wiki_link"%3A"https%3A%2F%2Fm.baike.com%2Fwikiid%2F2129442810616176116"}&msg=路由">路由 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</li>
<li><strong>TCP 层</strong>：保证可靠的数据传输。</li>
</ol>
<p>每一层都对下层的功能进行了扩展和优化，以满足不同的需求。</p>
<p>这种分层结构有助于提高网络的效率、可靠性和安全性。</p>
<p>TCP&#x2F;IP 协议的分层结构在某些方面确实具有代理模式的特点。</p>
<p>在代理模式中，一个对象代表另一个对象执行操作，提供了一种间接的方式来处理请求。</p>
<p>类似地，TCP&#x2F;IP 协议的分层结构：</p>
<ol>
<li><strong>抽象和封装</strong>：每一层都对下层的功能进行了抽象和封装。</li>
<li><strong>提供统一接口</strong>：上层通过下层提供的接口进行通信。</li>
<li><strong>隔离变化</strong>：下层的改变不直接影响上层。</li>
</ol>
<p>然而，它们也有一些区别：</p>
<ol>
<li><strong>协议是固定的</strong>：而代理模式中的代理对象可以根据需求进行定制。</li>
<li><strong>协议具有强制性</strong>：所有遵循 TCP&#x2F;IP 协议的系统都必须遵循相应的规范。</li>
</ol>
<p>尽管存在一些差异，但两者都关注于提供一种灵活、可扩展的方式来处理复杂的功能</p>
]]></content>
  </entry>
  <entry>
    <title>八股知识点</title>
    <url>/2024/06/01/%E5%85%AB%E8%82%A1%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="八股知识点"><a href="#八股知识点" class="headerlink" title="八股知识点"></a>八股知识点</h2><h3 id="1-是否会注入"><a href="#1-是否会注入" class="headerlink" title="1.是否会注入"></a>1.是否会注入</h3><p>不会</p>
<p>@Autowired<br>public void test(){<br>    HashMap&lt;String, Object&gt; map  &#x3D; new HashMap&lt;&gt;();<br>    map.put(“test”,”ces”);<br>    TestBean.instance &#x3D; map;</p>
<p>}这么写会依赖注入吗,还是说只会执行该方法一次</p>
<p>在你提供的代码中，<code>@Autowired</code> 注解用在了 <code>test</code> 方法上，但这样的使用方式是不符合 Spring 框架的依赖注入原则的。<code>@Autowired</code> 注解通常用于字段、构造函数或配置方法上，而不是普通的业务逻辑方法。</p>
<p>在你的例子中，<code>test</code> 方法会创建一个新的 <code>HashMap</code> 对象，并向其中添加一些数据，然后把这个 <code>HashMap</code> 赋值给 <code>TestBean</code> 的静态成员 <code>instance</code>。这个过程不会触发 Spring 的依赖注入机制，因为 <code>@Autowired</code> 在这里没有被用于任何可以被 Spring 管理的依赖项上。</p>
<p>所以，即使你在这个方法上使用了 <code>@Autowired</code>，Spring 也不会尝试去注入任何依赖。这个方法会按照普通的 Java 方法那样执行，并且只会执行一次（除非有其他代码在其他地方调用了这个方法）。</p>
<p>如果你希望 <code>TestBean</code> 的 <code>instance</code> 成员被 Spring 管理，并且能够通过依赖注入来设置，你应该这样做：</p>
<ol>
<li>将 <code>TestBean</code> 声明为一个 Spring Bean（例如，通过 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 或 <code>@Controller</code> 等注解）。</li>
<li>使用 <code>@Autowired</code> 在需要 <code>TestBean</code> 实例的地方进行注入。</li>
</ol>
<p>例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">java@Componentpublic class TestBean &#123;    public static TestBean instance;    // 其他成员和方法&#125;@Componentpublic class SomeOtherBean &#123;    private final TestBean testBean;    @Autowired    public SomeOtherBean(TestBean testBean) &#123;        this.testBean = testBean;        TestBean.instance = testBean; // 通常不推荐这样做，因为它破坏了依赖注入的原则    &#125;    // 其他成员和方法&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>TestBean</code> 被声明为一个 Spring Bean，并且 <code>SomeOtherBean</code> 通过构造函数注入获得了 <code>TestBean</code> 的实例。虽然我在这里还是把 <code>TestBean</code> 的实例赋值给了静态成员 <code>instance</code>，但这通常是不推荐的做法，因为它破坏了 Spring 的依赖注入原则，使得代码更难以测试和维护。更好的做法是直接使用 Spring 注入的 <code>TestBean</code> 实例，而不是依赖一个静态的 <code>instance</code> 成员。</p>
<p>其实我理解的是，Spring本意是想注入来着，就像Autowried写到set方法上的时候，他本意也是注入，实际上Spring的工作就是调用执行一下这个方法，有参数，spring就找自己管理的bean里有没有对应类型的(或者对应名字的)，没参数，所以就直接执行了</p>
<p>注入的动作，完成了方法的调用而已，只不过之前放到set方法的时候，会注入，这个不会注入了而已</p>
<p>简单理解就是autowired在方法上时，启动时他都会把这个方法调用一下，如果有参数则会在调用的时候尝试从初始化好的bean里注入实参</p>
<h3 id="2-DI注入和初始化的区别"><a href="#2-DI注入和初始化的区别" class="headerlink" title="2.DI注入和初始化的区别"></a>2.DI注入和初始化的区别</h3><p>在Spring框架中，初始化阶段可以执行的操作主要包括：</p>
<ol>
<li><strong>静态代码块</strong>：静态代码块在类加载时自动执行，是最优先执行的初始化操作12。</li>
<li><strong>构造方法</strong>：当类加载并实例化时，会执行构造方法中的逻辑12。</li>
<li><strong>实现ApplicationContextAware接口</strong>：通过实现<code>ApplicationContextAware</code>接口并重写<code>setApplicationContext()</code>方法，可以在Spring容器初始化时调用该方法，从而进行相关代码的初始化。这个类还可以获取Spring容器中的所有对象和信息2。</li>
<li><strong>使用@PostConstruct注解</strong>：<code>@PostConstruct</code>注解可以标注一个非静态的void方法，该方法会在类被Spring容器初始化后立即执行。因为执行时机在依赖注入和对象构造完成之后，所以适合进行一些需要在对象创建后才能进行的数据初始化操作1。</li>
</ol>
<p>这些操作可以帮助开发者在Spring容器启动后，执行必要的初始化任务，如资源加载、配置读取、数据初始化等，以确保应用程序的正常运行。</p>
<ul>
<li><strong>初始化</strong>：初始化是指在创建对象后，对对象的属性进行赋值或执行其他必要的设置操作。初始化通常由对象的构造函数或特定的初始化方法来完成。初始化的目的是为了确保对象在使用之前具有正确的初始状态。</li>
<li><strong>依赖注入</strong>：依赖注入是指在创建对象时，将对象所需的依赖项（其他对象或资源）注入到对象中。依赖注入的目的是减少对象之间的硬编码依赖，提高代码的灵活性和可维护性。依赖注入可以通过构造函数注入、属性注入、接口注入等方式实现。</li>
</ul>
<p>简而言之，初始化是为了设置对象的初始状态，而依赖注入是为了注入对象所需的依赖项，以实现松耦合的设计。</p>
<ul>
<li><p>DI是一种注入属性的机制,将Bean与注入属性解耦,类似构造方法</p>
</li>
<li><p>初始化则是类似静态代码块,但执行时机晚于构造方法也就是DI注入,并且主要针对于对象,静态代码块则早于构造方法,针对于整个类<br>初始化不仅可以执行复杂逻辑,也可以对属性赋值</p>
</li>
</ul>
<h3 id="3-finally的执行时机"><a href="#3-finally的执行时机" class="headerlink" title="3.finally的执行时机"></a>3.finally的执行时机</h3><p>在java中,finally虽然处于return语句的下方,但它的执行是在return返回结果之前执行的,属于java对于线程异常的<br>一个兜底策略,避免一些资源因为异常而未释放</p>
<ul>
<li>但需要注意,被final所修饰的不可变类型,就算执行了,也不会影响return的执行结果</li>
<li>一个原因是局部变量,一个原因是被final修饰的类</li>
</ul>
<p>4.Java的可变类型和不可变类型在 Java 中，可变类型和不可变类型的一些常见示例如下：</p>
<ul>
<li>不可变类型：<ul>
<li>整数类型（如 int、long 等）。</li>
<li>浮点类型（如 float、double 等）。</li>
<li>字符类型（char）。</li>
<li>布尔类型（boolean）。</li>
<li>字符串类型（String）。</li>
</ul>
</li>
<li>可变类型：<ul>
<li>数组。</li>
<li>集合类（如 ArrayList、HashSet 等）。</li>
</ul>
</li>
</ul>
<p>不可变类型的特点是其值一旦确定就不能被修改。例如，String 类型的字符串是不可变的，任何对字符串的操作都会返回一个新的字符串对象。</p>
<p>可变类型则可以在其生命周期内进行修改。</p>
<p>选择使用可变类型还是不可变类型取决于具体的需求和场景。不可变类型通常具有更好的安全性和简洁性，而可变类型在某些情况下提供了更灵活的操作方式。</p>
<ul>
<li>如何声明一个不可变类型<ul>
<li>成员变量私有化,限制外部访问,修饰为final</li>
<li>对外部不提供修改成员变量的方法</li>
<li>创建一个对象时,只能在构造方法里完成赋值,后续无法修改</li>
</ul>
</li>
</ul>
<h3 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5.开闭原则"></a>5.开闭原则</h3><p>继承在某些情况下可以被视为一种扩展方式，但它并不总是意味着符合开闭原则的扩展。</p>
<p>继承可以实现代码的重用和功能的扩展。通过继承现有类，可以获取其已有属性和方法，并在此基础上进行扩展或修改。</p>
<p>然而，在开闭原则的背景下，单纯的继承可能存在一些问题：</p>
<ol>
<li><strong>紧耦合</strong>：继承关系往往导致较高的耦合性，使得子类紧密依赖于父类的实现。</li>
<li><strong>灵活性受限</strong>：对父类的修改可能会影响到所有子类。</li>
<li><strong>不易扩展</strong>：当需要添加新的特性时，可能需要在父类中进行修改。</li>
</ol>
<p>为了更好地实现扩展，符合开闭原则，可以考虑以下几点：</p>
<ol>
<li><strong>依赖接口而非具体类</strong>：通过实现接口来提供扩展点。</li>
<li><strong>使用抽象类</strong>：在必要时定义抽象类，提供部分通用实现。</li>
<li><strong>组合而非继承</strong>：通过组合的方式来组合不同的功能模块。</li>
</ol>
<p>这样可以提高代码的灵活性和可扩展性，更容易进行扩展而不影响现有代码的稳定性。</p>
<p>哪些情况会破坏开闭原则</p>
<p>以下扩展方式可能会破坏开闭原则：(直接修改,直接依赖具体实现,重复代码,耦合性重)</p>
<ol>
<li><strong>直接修改源代码</strong>：每次扩展都需要直接修改现有代码，不符合开闭原则对修改关闭的要求。</li>
<li><strong>过度使用继承</strong>：当继承关系复杂且紧密时，可能导致代码的灵活性降低，不利于扩展。</li>
<li><strong>硬编码依赖</strong>：在代码中直接硬编码依赖特定的实现，使得扩展变得困难。</li>
<li><strong>全局变量或静态方法的使用</strong>：限制了代码的可复用性和可扩展性。</li>
<li><strong>紧密耦合的组件</strong>：组件之间耦合度过高，使得扩展一个组件可能影响其他组件。</li>
<li><strong>缺乏抽象</strong>：没有正确使用抽象类或接口，导致具体实现与扩展紧密绑定。</li>
<li><strong>代码重复</strong>：大量重复的代码使得维护和扩展变得复杂，容易引入错误。<br>为了避免破坏开闭原则，应该尽量采用更灵活的扩展方式，如使用抽象、接口、组合等设计模式，以及配置文件、<a class="link"   href="coco://sendMessage?ext={" s%24wiki_link"%3A"https%3A%2F%2Fm.baike.com%2Fwikiid%2F5672419420006108837"}&msg=插件">插件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>机制等技术。这样可以提高代码的可维护性和可扩展性，使系统更易于应对变化和扩展。</li>
</ol>
<h3 id="6-为什么要使用final修饰变量"><a href="#6-为什么要使用final修饰变量" class="headerlink" title="6.为什么要使用final修饰变量"></a>6.为什么要使用final修饰变量</h3><p>是的，在某些场景下，使用 <code>final</code> 可以作为一种兜底的安全策略。</p>
<p>将变量声明为 <code>final</code> 可以带来以下安全方面的好处：</p>
<ol>
<li><strong>防止意外修改</strong>：明确表示变量的值在指定区域内是不可变的，避免了意外的修改导致的错误。</li>
<li><strong>保证一致性</strong>：确保在特定的场景中，变量的值保持一致，不会因为误操作而改变。</li>
<li><strong>提高可读性</strong>：让开发者清楚地知道该变量是不可变的，增强了代码的可读性和可维护性。</li>
<li><strong>限制访问</strong>：限制了对变量的修改，从而减少了可能出现的错误和安全隐患。</li>
</ol>
<p>通过将关键变量或参数声明为 <code>final</code>，可以作为一种兜底的安全策略，增加代码的稳定性和可靠性。尤其在一些关键的场景中，如安全性要求较高的模块或处理重要数据的部分，使用 <code>final</code> 可以提供额外的保障。</p>
<p>然而，是否使用 <code>final</code> 作为兜底的安全策略，需要根据具体的情况来决定，权衡性能、灵活性和安全性等因素。</p>
<h3 id="7-Spring的ignoreDependencyInterface为什么需要在实例化阶段完成忽略"><a href="#7-Spring的ignoreDependencyInterface为什么需要在实例化阶段完成忽略" class="headerlink" title="7.Spring的ignoreDependencyInterface为什么需要在实例化阶段完成忽略"></a>7.Spring的ignoreDependencyInterface为什么需要在实例化阶段完成忽略</h3><p>是的，在<strong>反射创建 Bean</strong> 时忽略这些接口的方法，可以避免属性注入属性的冲突。</p>
<p>通过忽略这些接口的方法，Spring 可以确保在自动装配过程中不会尝试为这些接口相关的属性进行注入。</p>
<p>这样做有以下好处：</p>
<ol>
<li>防止重复注入：避免了在自动装配和接口回调方法中对相同属性的重复注入。</li>
<li>避免冲突：降低了属性注入过程中发生冲突的风险。</li>
<li>提高效率：减少了不必要的注入操作，提高了系统的性能。</li>
</ol>
<p>这种处理方式使得属性注入更加精确和可控，有助于提高系统的稳定性和可维护性。</p>
<h3 id="8-线上GC如何处理"><a href="#8-线上GC如何处理" class="headerlink" title="8.线上GC如何处理"></a>8.线上GC如何处理</h3><blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/imgs/%E5%85%AB%E8%82%A1%E6%96%87/%E7%BA%BF%E4%B8%8AGC%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86.png"
                      alt="线上GC如何处理"
                ></p>
</blockquote>
<h3 id="9-遇到一个设计题：亿级订单，千万日活，如何设计存储方案，容量，性能，拓展性，业务场景聚焦个大电商物流单，要给个成熟方案，大家思考一下"><a href="#9-遇到一个设计题：亿级订单，千万日活，如何设计存储方案，容量，性能，拓展性，业务场景聚焦个大电商物流单，要给个成熟方案，大家思考一下" class="headerlink" title="9.遇到一个设计题：亿级订单，千万日活，如何设计存储方案，容量，性能，拓展性，业务场景聚焦个大电商物流单，要给个成熟方案，大家思考一下"></a>9.遇到一个设计题：亿级订单，千万日活，如何设计存储方案，容量，性能，拓展性，业务场景聚焦个大电商物流单，要给个成熟方案，大家思考一下</h3><blockquote>
<p>存储层设计：<br>订单数据库： 使用分布式数据库（例如MySQL Cluster、TiDB等）存储订单信息，按照订单号进行分片存储，保证存储和查询的高性能。<br>缓存层： 使用分布式缓存系统（例如Redis Cluster）缓存热门订单数据和查询结果，减少数据库访问压力。<br>日志存储： 使用分布式文件系统（例如HDFS）存储订单操作日志，保证数据可追溯性和故障恢复能力。<br>应用层设计：<br>订单服务： 提供订单的创建、查询、修改和删除等接口，负责处理订单相关的业务逻辑。<br>物流服务： 提供物流信息的查询和更新接口，负责物流状态的实时更新和查询。<br>用户服务： 提供用户信息的查询和更新接口，负责管理用户账号和地址信息。</p>
</blockquote>
<h3 id="10-组合复用原则"><a href="#10-组合复用原则" class="headerlink" title="10.组合复用原则"></a>10.组合复用原则</h3><p>组合,主体和其它对象高度依赖,生命周期一致</p>
<p>聚合,主体和其它对象不强制依赖,可以早于晚于主体创建</p>
<h3 id="11-高可用的通用性解决方案"><a href="#11-高可用的通用性解决方案" class="headerlink" title="11.高可用的通用性解决方案"></a>11.高可用的通用性解决方案</h3><p><strong>主从架构</strong>：设置主节点和多个从节点，当主节点故障时，可以提升某个从节点为主节点继续提供服务。</p>
<blockquote>
<p>冗余,主从架通过冗余配置来保证服务的连续性</p>
</blockquote>
<p><strong>集群模式</strong>：如 Redis 集群等，通过多个节点共同承担数据存储和处理任务，提高整体的可靠性和容错性。</p>
<blockquote>
<p>容错,集群模式体现了容错性,增强系统应对故障的能力</p>
</blockquote>
<p><strong>数据复制</strong>：确保数据在多个节点之间进行实时或定期的复制，保证数据有多个副本。</p>
<blockquote>
<p>兜底,数据复杂是一种兜底手段,防止数据丢失,是持续动态的保障机制</p>
</blockquote>
<p><strong>负载均衡</strong>：使用负载均衡器将请求均匀分发到多个节点上，避免单个节点负载过高。</p>
<blockquote>
<p>分治思想,负载均衡运用分治思想,提高整体性能和资源利用率</p>
</blockquote>
<p><strong>监控与告警</strong>：实时监控系统的关键指标，一旦出现异常及时发出告警以便快速响应。</p>
<blockquote>
<p>预防,监控和告警起到预防的作用,让我们能及时发现问题</p>
</blockquote>
<p><strong>自动故障转移</strong>：通过程序或机制实现自动检测主节点故障并进行切换的过程。</p>
<blockquote>
<p>智能,自动故障转移展现了智能化的处理方式,减少人工干预</p>
</blockquote>
<p><strong>数据备份与恢复</strong>：定期进行数据备份，以便在出现严重故障时进行数据恢复。</p>
<blockquote>
<p>容灾,数据备份与恢复则是重要的容灾措施,确保在极端情况下数据的可恢复性,是最后的”保险防线”</p>
</blockquote>
<h3 id="12-分布式场景下会遇到的一些问题"><a href="#12-分布式场景下会遇到的一些问题" class="headerlink" title="12.分布式场景下会遇到的一些问题"></a>12.分布式场景下会遇到的一些问题</h3><p><strong>网络延迟和故障</strong>：节点之间通信可能出现延迟、丢包甚至网络中断，影响数据同步和协调。</p>
<blockquote>
<p>注册中心,用于管理节点的信息和状态,当网络延迟或故障发生时,注册中心可以帮组及时感知和处理</p>
<p>节点的状态变化,以保证数据听同步和协调的准确性</p>
</blockquote>
<p><strong>数据一致性问题</strong>：确保多个节点上的数据保持一致是一个挑战，可能出现数据不一致的情况。</p>
<blockquote>
<p>强一致&#x2F;最终一致,如MQ,可以在一定程度上缓解数据一致性问题,通过异步出来消息来协调不同节点的</p>
<p>数据操作</p>
</blockquote>
<p><strong>分布式事务问题</strong>：事务涉及多个节点时，协调事务的提交和回滚较为复杂。</p>
<blockquote>
<p>阶段提交,是解决分布式事务问题的一种常见方式，通过分阶段的操作来确保事务在多个节点上的一致性</p>
</blockquote>
<p><strong>节点故障</strong>：某个或某些节点可能出现故障，需要有应对机制来保障系统的正常运行。</p>
<blockquote>
<p>负载均衡和熔断机制,负载均衡可以将请求分发到不同的健康节点，减少故障节点的影响；熔断机制则可以在节点出现问题时快速切断对故障节点的调用，保障系统的稳定性</p>
</blockquote>
<p><strong>资源竞争</strong>：多个节点对共享资源的竞争可能导致性能问题。</p>
<blockquote>
<p>锁优化,资源分区,缓存,通过这些方式减缓竞争的激烈程度,以合理的机制和策略安排来实现更有序,高效的资源访问和利用,从而根本上提高整体性能,而不仅仅是”减缓竞争”这么简单</p>
</blockquote>
<p><strong>分布式锁问题</strong>：保证在分布式环境下对关键资源的互斥访问。</p>
<blockquote>
<p>数据库锁,Redis锁,Zookeeper,利用这些中间件的一些锁的特性来解决分布式锁的问题,和资源竞争相关但又不完全相同，它更强调在分布式环境下精确地控制对特定关键资源的访问顺序和互斥性。</p>
</blockquote>
<p><strong>数据分区问题</strong>：数据分布不合理可能导致某些分区负载过高或过低。</p>
<blockquote>
<p>分片,通过合理的数据分区（分片）可以解决数据分区问题，实现更均衡的负载分布</p>
</blockquote>
<p><strong>时钟同步问题</strong>：不同节点的时钟可能存在偏差，影响一些基于时间的判断和操作。</p>
<blockquote>
<p>网络时间协议,可以通过专门的时钟同步服务或协议来确保不同节点的时钟尽量保持一致，例如网络时间协议（NTP）等，避免因时钟偏差导致错误的判断和操作</p>
</blockquote>
<p><strong>安全问题</strong>：分布式系统面临更广泛的安全威胁和攻击面。</p>
<blockquote>
<p>WAF,可以抵御针对分布式系统的一些网络安全攻击，保护系统的安全</p>
</blockquote>
<h3 id="13-Mysql的redo和doubleWrite的区别"><a href="#13-Mysql的redo和doubleWrite的区别" class="headerlink" title="13.Mysql的redo和doubleWrite的区别"></a>13.Mysql的redo和doubleWrite的区别</h3><p>解决</p>
<ul>
<li><p>redo主要是用于解决事务场景下对于数据修改的持久性和一致性,对于数据的最终结果保证</p>
</li>
<li><p>double则是解决针对部分写失效场景问题,将完整的数据页写入到双写缓存,然后再分批写入数据文件,更侧重于</p>
</li>
</ul>
<p>​		数据写入磁盘时的一种保障机制(ibddata1文件中,属于系统表空间),具体数据则存储在对应独立表空间中</p>
<blockquote>
<p>本质是页数据(页大小默认16kb)写入到磁盘时,发现文件管理只能以4k的大小来写入,所以需要分批写入,</p>
<p>并且如果在写入时出现故障,导致写入数据不完整,导致无法使用该数据恢复</p>
<p>双写缓存此时就是作为页数据的一个兜底备份存在,避免写入出现问题</p>
</blockquote>
<h3 id="14-超时和熔断"><a href="#14-超时和熔断" class="headerlink" title="14.超时和熔断"></a>14.超时和熔断</h3><ul>
<li><p>超时是对于上游调用方的保护,避免因为下游长期处理导致上游调用超时,波及到它</p>
</li>
<li><p>熔断则是对下游被调用方的保护,避免上游的故障&#x2F;错误数据波及到下游,主动断开与上游的关联</p>
<blockquote>
<p>1.假设有一个电商系统，订单处理模块是下游，库存管理模块是上游。当订单处理模块在处理订单时需要调用库存管理模块来确认商品库存数量。</p>
<p>2.如果下游的订单处理模块发现上游的库存管理模块响应很慢，或者频繁返回错误（比如库存数据不一致等问题）。那么订单处理模块可能会采取以下行动：</p>
<p>3.首先，它可能会记录这些异常情况，并向系统的监控告警模块发送通知，让相关人员知道上游出现了问题。然后，它可能会暂时停止向库存管理模块发送新的请求，避免因继续请求而导致更多的错误或延迟累积。同时，它可以利用之前缓存的一些库存信息（如果有的话）来继续处理一些紧急的订单，以尽量减少对业务的影响。或者它可能会切换到一个备用的库存数据源（如果存在的话）来获取库存信息，直到原库存管理模块恢复正常。</p>
</blockquote>
</li>
</ul>
<h3 id="15-Redisson获取锁最大努力的思路"><a href="#15-Redisson获取锁最大努力的思路" class="headerlink" title="15.Redisson获取锁最大努力的思路"></a>15.Redisson获取锁最大努力的思路</h3><blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RedissonLock的trylock方法</span></span><br><span class="line"><span class="keyword">if</span>(ttl &gt;=<span class="number">0L</span>&amp;&amp;ttl&lt;time)&#123;</span><br><span class="line">  ((RedissonLockEntry) <span class="built_in">this</span>.commandExecutor.getNow(subscribeFuture)).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">  ((RedissonLockEntry) <span class="built_in">this</span>.commandExecutor.getNow(subscribeFuture)).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>这样的设计可以让程序在不同的时间和条件下都尝试去获取锁，尽量减少因时间限制或特定情况而错过获取锁的可能，体现了一种尽力争取、不轻易放弃的策略，从而达到尽最大努力不浪费机会的效果。</p>
<p>同时，通过这种分情况处理的方式，也增加了程序的容错性。它可以应对多种可能出现的场景和状态，使得锁的获取机制更加健壮和可靠，即便在一些不太理想的情况下也能做出相对合理的尝试和应对，降低因意外情况导致锁操作失败而引发问题的风险。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RedissonMultiLock的tryLock方法</span></span><br><span class="line"><span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">this</span>.unlockInner(acquiredLocks);</span><br><span class="line">      <span class="keyword">if</span> (waitTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         failedLocksLimit = <span class="built_in">this</span>.failedLocksLimit();</span><br><span class="line">         acquiredLocks.clear();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><br><span class="line">             iterator.previous();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>这里也是类似的情况,尽最大努力的尝试</strong></p>
<p>以往很多时候是采用快速失败的策略，即如果尝试获取失败就直接结束。</p>
<p>但像这种不断尝试的方式也有其应用场景和优势。它可以在一些对获取锁的确定性要求较高，或者希望尽可能争取到锁的情况下使用。这样可以避免因为一次尝试失败就立刻放弃，而是通过持续尝试来增加成功的机会，也许在某些特殊情况下，经过一段时间的努力后能够最终获取到锁，从而使得程序能够继续正常运行。当然，具体采用哪种方式还是要根据实际的业务需求和场景特点来权衡和选择。</p>
<p>复制重新生成</p>
</blockquote>
<h3 id="16-HashMap的驱逐思想"><a href="#16-HashMap的驱逐思想" class="headerlink" title="16.HashMap的驱逐思想"></a>16.HashMap的驱逐思想</h3><blockquote>
<p>1.在 Java 中，<code>HashMap</code>的<code>evict</code>参数用于控制是否在插入元素时进行驱逐（eviction）操作。驱逐操作的目的是在内存不足时，从<code>HashMap</code>中删除一些元素，以释放内存空间。</p>
<p>2.当<code>evict</code>参数设置为<code>false</code>时，表示在插入元素时不进行驱逐操作。在这种情况下，<code>HashMap</code>会尽可能地保存所有插入的元素，直到内存不足时才会进行驱逐操作。</p>
<p>3.当<code>evict</code>参数设置为<code>true</code>时，表示在插入元素时进行驱逐操作。在这种情况下，<code>HashMap</code>会在插入元素时，根据一定的策略删除一些元素，以释放内存空间。驱逐操作的具体策略可能会因<code>HashMap</code>的实现而有所不同。</p>
<p>4.需要注意的是，驱逐操作可能会导致<code>HashMap</code>中的元素被删除，因此在使用<code>evict</code>参数时，需要谨慎考虑其对应用程序的影响。</p>
</blockquote>
<h3 id="17-HashMap的增强点"><a href="#17-HashMap的增强点" class="headerlink" title="17.HashMap的增强点"></a>17.HashMap的增强点</h3><blockquote>
<p>**afterNodeAccess(Node&lt;K,V&gt; p)**：</p>
<ul>
<li>主要用于在节点被访问后执行一些自定义的后续动作。比如可以用于统计节点的访问频率，或者根据访问情况进行一些状态更新等。</li>
</ul>
<p>**afterNodeInsertion(boolean evict)**：</p>
<ul>
<li>当元素插入后，通过这个方法可以根据插入的情况以及 <code>evict</code> 的值进行不同的处理。比如如果 <code>evict</code> 为 <code>false</code> 且处于特定的创建模式，可以进行一些与创建模式相关的操作或记录；如果 <code>evict</code> 为 <code>true</code> ，可能执行与正常模式下插入后不同的逻辑。</li>
</ul>
<p>**afterNodeRemoval(Node&lt;K,V&gt; p)**：</p>
<ul>
<li>它允许在节点移除后进行一些清理或后续的处理工作。例如，可能需要释放与该节点相关的一些资源，或者对整个数据结构的状态进行相应调整。</li>
</ul>
</blockquote>
<h3 id="18-分布式组件理论"><a href="#18-分布式组件理论" class="headerlink" title="18.分布式组件理论"></a>18.分布式组件理论</h3><ul>
<li>好的架构不仅需要知道怎么用,还得知道为什么,可以带来什么好处,并且需要知道增加会带来什么问题,存在什么隐患</li>
<li>优质的架构不但要明晰其具体的运用之法，更要深刻理解背后的缘由，清楚其所能带来的益处，同时还要知晓增添它可能引发的各类问题。</li>
</ul>
<h4 id="1-架构演进-应用-软件-部署"><a href="#1-架构演进-应用-软件-部署" class="headerlink" title="1.架构演进(应用&#x2F;软件&#x2F;部署)"></a>1.<strong>架构演进</strong>(应用&#x2F;软件&#x2F;部署)</h4><blockquote>
<p>架构演进过程</p>
<p>可分为以下三个阶段,单机式,集中式,分布式微服务</p>
<p>下面演进过程中则是对应用模块的进一步划分,<strong>从一个整体到多个细分模块构成一个整体的过程</strong></p>
<ul>
<li><p>**单体架构(协调,整体)**：所有功能都集中在一个应用程序中，简单直接，但随着业务增长，会面临性能瓶颈、难以扩展和维护等问题,但简单直接、易于开发和部署。</p>
</li>
<li><p>**垂直架构(职责分离)**：将单体架构按照不同的业务功能进行垂直拆分，形成多个独立的子系统，一定程度上提高了可扩展性和维护性,强调一定的分层和专业性。</p>
</li>
<li><p>**分布式架构(分治,压力均摊)**：各个子系统进一步分布部署在不同的节点上，通过网络进行通信和协作，提升了系统的处理能力和可用性,保证了服务的高可用性、容错性等。</p>
</li>
<li><p><strong>SOA（面向服务架构,标准协议）</strong>：强调服务的概念，将系统功能封装为独立的服务，通过标准的接口进行交互，提高了系统的灵活性和复用性,强调服务的重用性和松耦合。</p>
</li>
<li><p>**微服务架构(独立,自主)**：将服务进一步细化和拆分，每个微服务都可以独立部署、扩展和维护，具有更高的灵活性、敏捷性和可扩展性,强调敏捷性、弹性等。</p>
</li>
<li><p>演进的过程从逻辑划分变为物理划分</p>
</li>
<li><p>分布式和微服务有点类似多面手和螺丝钉的区别,相当于是通过一个整体的过程,协调多个服务完成一件事,而微服务仅仅专注自己的职责,更单一</p>
<blockquote>
<p>微服务和分布式有很强的相关性，主要体现在以下几个方面：</p>
<p>首先，微服务的实现通常需要依托于分布式技术。每个微服务都可能运行在不同的节点上，这本身就是一种分布式的部署方式，通过分布式的基础设施来支撑微服务之间的通信、协调和资源分配。</p>
<p>其次，分布式强调的资源分散和协同工作的理念与微服务的架构思想是契合的。微服务架构也是为了更好地实现系统的分布式特性，比如提高系统的可扩展性、容错性等，这些都是分布式所追求的目标。</p>
<p>再者，从系统的构建和运行角度来看，微服务和分布式都致力于解决大规模复杂系统的问题，它们相互配合，共同营造出一个高效、灵活的系统环境。</p>
<p>比如，在一个大型的应用系统中，通过分布式部署来将各个微服务分布到不同的服务器上，以实现性能的提升和资源的合理利用，二者是紧密结合在一起的。所以不能单纯地将它们割裂开来，它们在很多方面是相互关联、相互促进的</p>
</blockquote>
</li>
<li><p>所以,架构的演进过程中,可能包含了以往的一些特性,并且在此基础上进行了增强</p>
</li>
<li><p>最后总结一句,分布式重在部署方式及协调整体,而微服务重在服务自治,灵活,扩展,敏捷</p>
</li>
</ul>
<p>最后是部署,将服务部署到不同的机器上,达到对外暴露服务</p>
<p>总结:</p>
<ul>
<li>我觉得软件架构是教你如何设计,应用架构则是教你如何组合,部署架构则是如何对外服务</li>
<li>软件架构<strong>设计</strong>关乎如何以最有的方式组织和构建软件的各个部分,包括模块划分,层次结构,交互方式等,以满足功能和非功能和需求</li>
<li>应用架构的<strong>组合</strong>则是强调的是不同的应用组件或模块如何协同工作,形成一个有机的整体,以实现特定的业务功能和流程</li>
<li>部署架构则是侧重于如何将软件系统部署到实际的硬件环境中,以提供稳定,可靠的<strong>服务</strong>,它涉及到服务器的配置,网络的布局,资源的分配等方面,直接影响着软件系统的可用性和性能表现</li>
<li>三者互相影响,互相成就,共同决定了一个软件系统的质量和能效</li>
</ul>
</blockquote>
<blockquote>
<p>为什么要进化</p>
<p>在这个演进过程中，是为了不断适应业务的发展变化、提高系统性能、增强可靠性和可维护性等，以更好地满足不断增长的用户需求和应对各种挑战。</p>
<p>我主要是从系统架构设计、性能优化、业务需求满足以及资源管理等方面来理解这个问题的。</p>
<ul>
<li><p>从<strong>系统架构设计角度</strong>来看，物理划分是架构演进的一个重要手段，涉及如何合理布局和构建系统的物理架构。</p>
</li>
<li><p>从<strong>性能优化</strong>方面，这是推动进行物理划分的重要动力之一，关乎如何通过这种方式提升系统的整体性能表现。</p>
</li>
<li><p>从<strong>业务需求</strong>满足的层面，是考虑怎样更好地适应业务不断发展变化以及多样化的要求。</p>
</li>
<li><p>从<strong>资源管理</strong>的角度，则是要处理好资源分配、协调和利用等一系列相关问题，以保障系统的稳定高效运行。通过这些方面的综合考量，能更全面、深入地理解从逻辑划分到物理划分所涉及的核心问题。</p>
</li>
<li><p>架构演进的核心,就是需求带来变化,没有需求谈何变化</p>
</li>
<li><p>需求(表)是拆分的<strong>因</strong>,资源合理利用(内核)则是是拆分的<strong>果</strong>,但也不能简单的将其<strong>割裂</strong>的来看待,实际它们之间是<strong>相互关联,相互影响</strong>的动态过程</p>
<blockquote>
<ul>
<li>在追求资源合理利用的过程中,可能又会反过来影响对需求的进一步理解和完善</li>
<li>同时,资源的合理利用也并非仅仅是需求推动的唯一结果,它本身也是为了保障系统的良好运行和持续发展,所以它们的关系是较为复杂且紧密交织的</li>
</ul>
</blockquote>
</li>
</ul>
<p>发展的几个阶段:</p>
<ol>
<li><strong>单机架构阶段（大一统阶段）</strong>：<ul>
<li><strong>特点</strong>：所有数据和计算都集中在一台机器上，类似于中央集权的制度。</li>
<li><strong>优势</strong>：简单直接，无需考虑复杂的网络通信和分布式协调问题。</li>
<li><strong>挑战</strong>：随着数据和计算需求的增长，单机性能可能成为瓶颈，扩展性受限。</li>
<li><strong>比喻</strong>：类似于历史上的大一统时期，中央集权，所有资源和任务都由中央统一管理和执行。</li>
</ul>
</li>
<li><strong>集中式架构阶段（诸侯阶段）</strong>：<ul>
<li><strong>特点</strong>：存在一个中心化的服务器或节点，负责统一管理和协调整个系统，其他节点或组件具有一定的自治权和独立性。</li>
<li><strong>优势</strong>：通过分布式处理提高了系统的可扩展性和灵活性，同时保留了中心化管理的优势。</li>
<li><strong>挑战</strong>：中心服务器可能成为单点故障的风险点，对中心服务器的依赖可能导致整个系统的可靠性问题。</li>
<li><strong>比喻</strong>：类似于历史上的诸侯阶段，中心服务器类似于周天子，其他节点类似于诸侯，各自为政但受中心服务器统一管理。</li>
</ul>
</li>
<li><strong>分布式架构阶段（权利下放阶段）</strong>：<ul>
<li><strong>特点</strong>：数据和计算任务被分散到多个节点或服务器上，这些节点之间通过网络进行通信和协调，形成一个去中心化的系统。</li>
<li><strong>优势</strong>：极大地提高了系统的可扩展性、容错性和灵活性。由于数据和计算被分散到多个节点上，可以充分利用集群的计算和存储能力，同时减少了单点故障的风险。</li>
<li><strong>挑战</strong>：分布式系统面临着复杂的网络通信、数据一致性和并发控制等问题。需要设计合理的分布式算法和协议来确保系统的正确性和性能。</li>
<li><strong>比喻</strong>：类似于权力下放的社会制度，各个节点或服务器拥有更多的自主权和决策权，能够更快地响应变化并做出决策，整个系统更加灵活和健壮。</li>
</ul>
</li>
<li><strong>总结</strong>：架构方式在不同的阶段下存在的问题从性能瓶颈，变为极度依赖，再到数据同步，网络通讯，并发控制等问题，随之带来的好处分别是结构简单（维护方便），职责分离（中心协调，其它承担具体任务），高度自治，扩展方便（独立自足，增加方便）</li>
</ol>
</blockquote>
<blockquote>
<p>常用架构:</p>
<p><strong>微服务架构</strong>：灵活性高，易于扩展和维护。</p>
<p><strong>分布式架构</strong>：提升系统的处理能力和可靠性。</p>
<p><strong>面向服务架构（SOA）</strong>：便于服务的集成和复用。</p>
<p><strong>分层架构（如三层架构）</strong>：清晰划分功能层次。</p>
<p><strong>事件驱动架构</strong>：适合对事件响应要求高的场景。</p>
<p><strong>CQRS（命令查询职责分离）架构</strong>：明确区分数据操作类型。</p>
<p><strong>Actor 模型架构</strong>：适用于并发处理复杂的情况。</p>
<p><strong>模型-视图-控制器（MVC）架构</strong>：广泛应用于 Web 开发。</p>
<p><strong>模型-视图-视图模型（MVVM）架构</strong>：常用于前端开发。</p>
<p><strong>领域驱动设计（DDD）架构</strong>：强化业务领域概念。</p>
<p><strong>无服务器架构</strong>：简化开发和运维。</p>
</blockquote>
<blockquote>
<p>设计的融和:</p>
<p>为满足业务需求与达成理想效果，架构与设计往往并非单一形态，而是会不断融合与创新</p>
<p>总结:</p>
<p><strong>设计并不孤单,而会不断融合,一起拥抱变化吧</strong></p>
</blockquote>
<h4 id="2-分布式场景"><a href="#2-分布式场景" class="headerlink" title="2.分布式场景"></a>2.<strong>分布式场景</strong></h4><blockquote>
<p><strong>服务治理与交互</strong>：</p>
<ul>
<li>注册中心（如 Eureka、Consul、Spring Cloud Alibaba Nacos）：用于服务的自动注册与发现。</li>
<li>远程调用（如 gRPC、Thrift、Dubbo）：实现不同服务之间的高效通信。</li>
<li>负载均衡（如 Nginx、F5）：将请求均衡分发到多个后端服务。</li>
<li>网关（如 Spring Cloud Gateway）：统一入口，进行路由和过滤等操作。</li>
<li>服务降级&#x2F;限流（如 Sentinel、Hystrix）：保障系统在异常或高负载时的稳定性。</li>
</ul>
<p><strong>通讯与消息传递</strong>：</p>
<ul>
<li>消息队列<ul>
<li>高性能（如 Kafka）：分布式流处理平台，处理海量数据和高并发。</li>
<li>可靠（如 RabbitMQ、RocketMQ、ActiveMQ）：确保消息可靠传输（使用确认机制、事务、持久化、副本方式保证可靠性）。</li>
<li>低延迟（如 ZeroMQ）：适用于对延迟要求极高的场景。</li>
</ul>
</li>
<li>分布式通信协议<ul>
<li>ZooKeeper 协议：分布式协调服务的基础协议。</li>
<li>Raft 协议：用于实现分布式一致性的主流协议之一。</li>
<li>Paxos 协议：经典的分布式一致性协议。</li>
</ul>
</li>
</ul>
<p><strong>数据存储和管理</strong>：</p>
<ul>
<li>结构化存储<ul>
<li>关系型数据库（如 MySQL、PgSQL、Oracle 等）：传统的结构化数据存储。</li>
</ul>
</li>
<li>非结构化存储<ul>
<li>内存型数据库（如 Redis）：高速缓存和数据存储。</li>
<li>文档型数据库（如 MongoDB）：灵活的文档存储。</li>
<li>文件型数据库（如 FastDFS）：分布式文件存储。</li>
<li>对象型数据库（如 MinIO）：对象存储。</li>
</ul>
</li>
</ul>
<p><strong>协调与同步</strong>：</p>
<ul>
<li>分布式协调（如 ZooKeeper）：实现分布式系统的协调工作(管理者)。</li>
<li>数据同步（如 Canal）：监听数据库变更进行同步。</li>
<li>事务（如 Seata）：分布式事务处理框架。</li>
<li>任务同步<ul>
<li>定时任务（如 XXL-job，Quartz）：定时执行任务。</li>
</ul>
</li>
<li>状态同步<ul>
<li>状态机（如 Spring Statemachine）：管理状态的流转。</li>
</ul>
</li>
</ul>
<p><strong>配置管理</strong>：</p>
<ul>
<li>配置中心（如 Spring Cloud Config，Spring Cloud Alibaba Nacos Config）：集中管理系统配置。</li>
</ul>
<p><strong>安全管理</strong>：</p>
<ul>
<li>权限框架（如 Shiro、Spring Security）：实现访问控制和权限管理。</li>
</ul>
<p><strong>容错与恢复</strong>：</p>
<ul>
<li>限流&#x2F;熔断（如 Sentinel、Hystrix）：限制流量和防止故障扩散。</li>
<li>故障自动恢复 （如 Kubernetes）：自动处理节点或服务故障。</li>
<li>重试策略（如 Spring Retry）：对失败请求进行重试。</li>
</ul>
<p><strong>监控与追踪</strong>：</p>
<ul>
<li>日志记录（ELK、Flume）：收集和分析日志。</li>
<li>链路追踪（如 Zipkin、Jaeger、SkyWalking）：追踪请求的全链路。</li>
<li>监控（如 Prometheus、Grafana、Zabbix、Nagios）：对系统性能等进行监控。</li>
</ul>
<p><strong>部署和运维</strong>：</p>
<ul>
<li>容器（如 Docker）：应用容器化技术。</li>
<li>容器编排（如 Kubernetes）：管理容器集群。</li>
</ul>
<p><strong>数据处理和分析</strong>：</p>
<ul>
<li>大数据处理框架（如 Hadoop、Spark）：处理大规模数据。</li>
<li>流处理技术（如 Flink）：实时流数据处理。</li>
</ul>
</blockquote>
<h4 id="3-分布式理论"><a href="#3-分布式理论" class="headerlink" title="3.分布式理论"></a>3.<strong>分布式理论</strong></h4><ul>
<li><p>CAP(基础理论)</p>
<p><strong>分布式理论特性</strong>：</p>
<ol>
<li>分区（Partition）：网络可能将分布式系统中的节点分隔开，导致部分节点之间无法正常通信。</li>
<li>容错（Fault Tolerance）：系统在面对各种故障（如节点故障、网络故障等）时，仍能继续正常运行或在故障恢复后能够恢复到正确的状态。</li>
<li>一致性（Consistency）：多个节点的数据在经过一系列操作后能够达到一种符合预期的一致状态。</li>
</ol>
<p><strong>实现方式和解决方案</strong>：</p>
<p><strong>分区</strong>：</p>
<ol>
<li>数据分区策略：根据数据特征（如用户 ID、地理位置、业务类型等）将数据划分到不同的分区，以减少分区发生时的数据不一致和通信开销。例如哈希分区、范围分区。</li>
<li>负载均衡：确保各个分区的工作负载相对均衡，避免某些分区成为性能瓶颈。</li>
<li>跨分区事务处理机制：设计合适的机制来处理涉及多个分区的事务，保证数据的一致性。</li>
</ol>
<p><strong>容错</strong>：</p>
<ol>
<li>副本技术：在不同的节点上保存数据的副本，当某个节点出现故障时，使用副本进行恢复。</li>
<li>故障检测和恢复机制：通过心跳检测等方式及时发现故障节点，并能够自动或手动进行恢复。</li>
<li>数据备份和恢复策略：定期对数据进行备份，在出现严重故障时能够快速恢复数据。</li>
</ol>
<p><strong>一致性</strong>：<br>一致性协议，如 Raft 协议、Paxos 协议等，定义了节点之间的通信规则、数据复制方式以及在出现故障或网络分区等异常情况下的处理策略，以确保数据的一致性。</p>
<p><strong>分布式应用发展历程</strong><br>分布式理论—&gt;三高特性—&gt;微服务架构—&gt;部署方式(云)—&gt;网络(CDN)—&gt;客户端(APP,WEB)</p>
<blockquote>
<p>前两个阶段是基于业务需求所需的必备特性,需要分布式才能够支持如此大用户场景,压力,所以需要考虑这些</p>
<p>微服务阶段,则是属于架构设计,技术选型,在此阶段需要选出适合业务场景的组件,服务,模块,拆分方式</p>
<p>部署阶段则是最靠近用户的一次,在此阶段需要完成应用的部署,监控,容灾等等场景</p>
<p>最后两个阶段则是为了满足客户的需求而产生的方案,比如CDN缓存加速,弱网访问</p>
</blockquote>
<p><strong>总结</strong></p>
<blockquote>
<ol>
<li>基础特性—&gt;架构&lt;—三高特性,都是为架构所服务的,基础特性是标准,三高特性是目标,<strong>架构是基于基础特性标准上的具体实现,在实现的过程中,达到三高特性的最终目标</strong></li>
<li>可以理解问分布式基础是<strong>下限,是警告,是标准</strong>,告诉你怎么做,需要怎么做 三高则是上限,是目标是最终结果,具体架构设计是沿着下限向上限进化的</li>
<li>各种分布式组件则是为了<strong>满足下限和上限的具体实现</strong></li>
<li>类似的还有设计原则,下限为SOLID,上限为<strong>高内聚,低耦合,可测试,可扩展等等</strong>,具体的实现就是23种设计模式</li>
</ol>
</blockquote>
</li>
<li><p>BASE(CAP的具体实现)</p>
</li>
<li><p>具体场景</p>
<blockquote>
<p><strong>一致性协议</strong></p>
<p>一致性协议是分布式系统中用于保持数据一致性的一种机制，常见的一致性协议包括 Raft、Paxos、ZAB 等。不同的分布式组件可能会使用不同的一致性协议，具体使用场景也会有所不同。以下是一些分布式组件使用一致性协议的具体场景：</p>
<ul>
<li><strong>ZooKeeper</strong>：ZooKeeper 是一个开源的分布式协调服务，它使用 ZAB（ZooKeeper Atomic Broadcast）协议来保证数据的一致性和可靠性。ZAB 协议是一种基于主从复制的一致性协议，它通过选举一个领导者来协调分布式系统中的数据更新操作。ZooKeeper 常用于分布式锁、分布式队列、配置管理等场景。</li>
<li><strong>etcd</strong>：etcd 是一个高可用的分布式键值存储系统，它使用 Raft 协议来保证数据的强一致性。etcd 常用于存储分布式系统的关键配置信息，例如数据库连接信息、服务发现信息等。Raft 协议通过选举一个领导者来保证数据的一致性和可靠性，同时还支持数据的备份和恢复。</li>
<li><strong>Consul</strong>：Consul 是一个开源的服务发现和配置管理工具，它使用 Raft 算法作为其分布式一致性协议，确保在分布式环境下数据的一致性和可靠性。Consul 具备强大的健康检查功能，可以监控服务的状态并根据设定的规则自动剔除故障节点。它支持多种健康检查方式，如 TCP、HTTP、Docker 容器等，确保服务的稳定性和可用性。</li>
<li><strong>Nacos</strong>：Nacos 是一个开源的动态服务发现、配置管理和服务管理平台，它使用 Distro 协议来保证数据的一致性。Distro 协议是一种最终一致性协议，它通过在多个节点之间复制数据来保证数据的一致性。Nacos 常用于微服务架构中的服务发现和配置管理。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="4-MQ"><a href="#4-MQ" class="headerlink" title="4.MQ"></a>4.<strong>MQ</strong></h4><blockquote>
<ul>
<li>解耦<ul>
<li>在传统架构中，有效避免了服务间的直接强关联，降低了服务之间相互影响的风险，当某一服务出现故障时，能极大减少对其他服务及应用整体性能的不良影响。</li>
<li>从传统的 A 直接调用 B 的模式，转变为 A 调用 C，再由 C 调用 B，通过引入第三方（如 MQ）的方式，实现服务间的灵活解耦。</li>
</ul>
</li>
<li>异步<ul>
<li>针对数据（尤其是高频次）量大且可能对主流程造成显著影响的情况。</li>
<li>通过将相关数据置入队列，能够确保在不阻塞当前主流程运行的同时，还可维持良好的用户体验。</li>
</ul>
</li>
<li>削峰<ul>
<li>针对突发的大量请求导致服务处理效率降低，进而使应用性能下降的状况。</li>
<li>将数据放入队列中进行缓冲，随后逐步消费，实现平稳处理，从而有效降低即时的高压力。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5-锁"><a href="#5-锁" class="headerlink" title="5.锁"></a>5.<strong>锁</strong></h4><h4 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.<strong>事务</strong></h4><p>MQ&#x2F;锁&#x2F;事务 围绕着数据一致性来说</p>
<h4 id="7-定时任务"><a href="#7-定时任务" class="headerlink" title="7.定时任务"></a>7.<strong>定时任务</strong></h4><p>围绕着协调来说</p>
<h4 id="8-限流-熔断-故障恢复"><a href="#8-限流-熔断-故障恢复" class="headerlink" title="8.限流&#x2F;熔断&#x2F;故障恢复"></a>8.<strong>限流&#x2F;熔断&#x2F;故障恢复</strong></h4><h4 id="9-超时-重试"><a href="#9-超时-重试" class="headerlink" title="9.超时&#x2F;重试"></a>9.<strong>超时&#x2F;重试</strong></h4><p>限流&#x2F;熔断&#x2F;故障恢复&#x2F;超时&#x2F;重试 围绕着高可用来说</p>
<h4 id="10-服务治理与交互"><a href="#10-服务治理与交互" class="headerlink" title="10.服务治理与交互"></a>10.<strong>服务治理与交互</strong></h4><h4 id="11-监控与追踪"><a href="#11-监控与追踪" class="headerlink" title="11.监控与追踪"></a>11.<strong>监控与追踪</strong></h4><h4 id="12-安全"><a href="#12-安全" class="headerlink" title="12.安全"></a>12.<strong>安全</strong></h4><h3 id="19-并发原则"><a href="#19-并发原则" class="headerlink" title="19.并发原则"></a>19.并发原则</h3><ul>
<li>并发设计</li>
</ul>
<blockquote>
<p><strong>有序性</strong></p>
<p>1.<strong>“串行一致”和”先行发生”这两个原则并不是平级的概念</strong>，它们在并发编程的理论体系中扮演着不同角色，但相互关联，共同支撑着并发程序的正确性和理解性。</p>
<ul>
<li><strong>先行发生（Happen-Before）原则</strong>：这是一个更为基础的概念，它定义了程序中操作之间的偏序关系，说明了哪些操作必须在其他操作之前执行。先行发生原则为并发程序中的内存访问、线程交互等提供了逻辑上的顺序保证，是理解和分析并发程序行为的基础框架。</li>
<li><strong>串行一致（Sequential Consistency）</strong>：这是一种内存一致性模型，是最强的一种一致性模型。它要求多线程程序在执行结果上与某个串行执行的顺序相对应，即程序的执行仿佛是在某个不确定的串行顺序下进行的，尽管实际可能是乱序执行。串行一致性可以看作是程序执行结果的一种理想状态，而先行发生原则则是达成这一状态的机制之一。</li>
</ul>
<p>简而言之，先行发生原则是构建并发程序逻辑顺序的基础规则，而串行一致性是一种理想化的内存交互视图，它依赖于先行发生原则等机制来实现。因此，从某种程度上说，先行发生原则可以视为实现串行一致性的工具之一，两者在逻辑上有包含和被包含的关系，但分别关注于操作间的顺序关系和整体执行效果。</p>
<p>2.<strong>重排序问题的核心确实与操作之间的依赖关系紧密相关</strong>。当存在依赖的操作被不恰当地重排序，即执行顺序与逻辑上的预期顺序不一致时，确实可能导致程序行为偏离预期，不论是局部变量还是全局变量，也不论是单线程还是多线程环境。</p>
<ul>
<li><strong>局部变量</strong>：尽管单线程中的局部变量通常不涉及并发访问问题，但若这些变量的操作之间存在逻辑依赖（例如，一个变量的值依赖于前一个变量的计算结果），不恰当的重排序可能导致逻辑错误，尽管这种情况较为少见。</li>
<li><strong>全局变量&#x2F;静态变量&#x2F;实例变量</strong>：在多线程环境下，全局变量等共享状态的重排序问题更为显著，因为多个线程可能同时访问和修改这些变量，不恰当的重排序极易引发数据竞争和一致性问题，导致数据损坏或程序崩溃。</li>
<li><strong>单线程环境</strong>：虽然单线程中并发问题较少，但重排序仍可能通过影响依赖关系，间接导致程序逻辑错误，尤其是当依赖于特定顺序的计算或I&#x2F;O操作时。</li>
<li><strong>多线程环境</strong>：在多线程中，除了依赖关系外，重排序还会与数据竞争结合，显著增加出现不可预测行为的风险，如脏读、丢失更新等并发问题。</li>
</ul>
<p>总之，理解操作之间的依赖性，并在必要时使用适当的同步机制（如锁、volatile、原子操作等）来控制重排序，是保证程序在各种环境下的正确性和一致性的重要手段。</p>
<p>3.<strong>JMM内存模型</strong>,它是Java虚拟机规范定义的一种内存模型,描述了Java各种变量(线程共享变量)的访问规则,以及在JVM中如何将工作内存中修改后的变量同步到主内存的这种底层细节,并且屏蔽了CPU和内存的交互细节,统一了不同平台下的内存交互方式</p>
<ul>
<li><p>访问规则</p>
<ul>
<li>将内存空间分为线程私有的工作内存和线程共享的主内存</li>
<li>访问时先从主内存拷贝一份副本到工作内存中</li>
<li>修改则先在工作内存中完成,然后在主内存中完成交互</li>
</ul>
</li>
<li><p>同步方式</p>
<ul>
<li>当线程修改完成自己的数据后,通过(比如 volatile 变量的特殊规则、锁机制等)这些机制将数据同步到主内存中</li>
</ul>
</li>
<li><p>并发问题</p>
<ul>
<li><p>原子</p>
<ul>
<li>可以使用Lock和Synchroized这些锁机制来保证执行的完整性,不会被其它的线程给打断</li>
<li>Synchroized底层是通过对象头的锁持有标记实现互斥,在字节码则是采用lock指令锁住区间实现操作原子性</li>
<li>Lock底层则是通过State标记实现互斥,CAS操作实现操作原子性</li>
</ul>
</li>
<li><p>有序&#x2F;可见</p>
<ul>
<li><p>可以使用使用Lock和Synchroized这些锁机制以及volatile关键字来保证执行的有序和对数据</p>
<p>修改后对其它线程的可见</p>
</li>
<li><p>Lock和Synchroized通过锁的互斥特性来保证一定的有序性(通过阻塞和唤醒机制来保证的),在进入临界区时会强制刷新自己的数据,并且在释放锁时将数据刷新会主内存,这样其它的线程就能看到最新的数据</p>
</li>
<li><p>Volatile则是通过内存屏障来保证有序性(读写屏障,读向上,写向下),MESI协议来保证可见性(监听)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>三大特性</li>
</ul>
<blockquote>
<p>可见&#x2F;有序性</p>
<ul>
<li>Volatile<ul>
<li>MESI协议<ul>
<li>操作系统内存—&gt;CPU缓存</li>
<li>状态</li>
<li>消息总线</li>
</ul>
</li>
<li>指令重排序<ul>
<li>编译器</li>
<li>CPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>原子性</p>
<ul>
<li><p><strong>竞争影响执行的效率</strong></p>
</li>
<li><p>锁,Java中使用锁来保证执行操作的原子性(同步且互斥)</p>
<ul>
<li><p>悲观锁</p>
<blockquote>
<p>1.Synchroized</p>
<p>Java实现的其中一种锁机制,是java的一个内部使用关键字,直译叫做同步的,用于保证组合操作执行的原子性,</p>
<p>通过进入和出去锁时的Monitor实现线程的唤醒和竞争锁,并且在性能考虑上有一定的优化,支持偏向锁(无竞争&#x2F;竞争少),轻量锁(交替执行),重量锁(大量竞争),并且在一定场景下会发生锁粗化(锁的范围增大),锁消除(不存在竞争时,JVM会将锁清除),锁升级和退化(对于锁的使用和性能动态变化,根据实际竞争情况进行调整,降低资源的消耗,提高性能),涉及到应用态到内核态的切换</p>
<p>2.Lock</p>
<p>支持打断,超时,限定条件,可重入等等特性,使用Java实现,相对Syn更灵活,不用和CPU直接打交道,<br>底层使用同步队列+CAS机制实现</p>
</blockquote>
</li>
<li><p>乐观锁(不互斥,不阻塞,不同步)</p>
<blockquote>
<p>1.CAS</p>
<p>它存在内存值,修改值,预期值的概念,首先内存中的值一定是最新的,而修改值和预期值都为线程所</p>
<p>持有,预期值不一定是最新的,可能会被其它线程修改</p>
<p>然后就是修改的流程了,线程会先将自己的预期值和内存值进行比较,相同则完成自己的修改,否则<br>就会自旋,当一直比较失败,就会尝试获取内存中的最新值覆盖自己的预期值,再次尝试修改,但存在一定的问题,容易造成CPU空转的问题,导致资源一直被浪费</p>
<p>最后,为了避免上面的问题,通常会设置一定的自旋上限,然后放弃修改</p>
<p>2。使用注意事项</p>
<ul>
<li><p><strong>使用线程安全的集合或并发数据结构</strong>：可以考虑使用线程安全的集合或并发数据结构来替代<code>AtomicInteger</code>。例如，可以使用<code>ConcurrentHashMap</code>或<code>ConcurrentLinkedQueue</code>等数据结构来存储和操作共享数据，这些数据结构在多线程环境下具有更好的并发性和性能。</p>
</li>
<li><p><strong>调整线程池配置</strong>：可以调整线程池的配置，例如增加线程池的大小或调整任务队列的大小，以减少线程竞争和阻塞的可能性。</p>
</li>
<li><p><strong>避免共享状态</strong>：尽量避免在多线程环境中共享可变状态。如果可能的话，可以将任务设计为无状态的，或者通过参数传递数据而不是共享变量。</p>
</li>
<li><p><strong>使用锁或同步机制</strong>：如果必须共享状态并且需要确保线程安全，可以使用适当的锁或同步机制来保护共享数据。例如，可以使用<code>synchronized</code>关键字或<code>ReentrantLock</code>等锁来实现线程同步。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>总结</p>
<blockquote>
<p>在并发场景中，<strong>线程通讯</strong>和<strong>资源分配</strong>的确是至关重要。</p>
<p>线程通讯确保了不同线程之间能够有效地协调和交互信息。例如，通过共享变量、消息总线、信号量等机制，线程可以传递状态、通知任务完成或请求其他线程执行特定操作。良好的线程通讯机制可以避免数据不一致、竞态条件等问题。比如在生产者-消费者模式中，生产者线程和消费者线程通过特定的通讯方式来协调生产和消费行为。</p>
<p>资源分配则直接关系到系统的性能和稳定性。合理地分配诸如内存、CPU 时间、网络带宽等资源，能够避免资源竞争导致的死锁、性能下降等情况。比如，在多线程访问数据库时，需要合理地分配数据库连接资源，以确保线程不会因为竞争连接而阻塞。同时，对于关键资源的分配策略也需要精心设计，以满足不同场景下的需求。</p>
<p>总之，在并发场景下，对线程通讯和资源分配的妥善处理是构建高效、可靠的并发系统的关键要素。它们相互配合，共同保障系统在高并发环境下的正常运行和良好性能表现。</p>
</blockquote>
</li>
</ul>
<h3 id="20-CPU是如何保证同步的"><a href="#20-CPU是如何保证同步的" class="headerlink" title="20.CPU是如何保证同步的"></a>20.CPU是如何保证同步的</h3><ul>
<li><strong>Synchroized</strong></li>
</ul>
<blockquote>
<p>在Linux环境下，针对Java中<code>synchronized</code>关键字及其在HotSpot虚拟机中的不同锁实现机制（轻量级锁、偏向锁、重量级锁）所依赖的关键机制和与Linux紧密相关的指令或函数，可以总结如下：</p>
<ul>
<li><p><strong>轻量级锁</strong>:</p>
<ul>
<li><strong>核心依赖</strong>：利用CPU的<code>cmpxchg</code>指令执行Compare-And-Swap操作，以原子性尝试获取锁。</li>
<li><strong>自旋优化</strong>：在自旋等待期间，可能会使用<code>pause</code>指令来减少CPU的空闲循环开销。</li>
</ul>
</li>
<li><p><strong>偏向锁</strong>:</p>
<ul>
<li><strong>初始化与撤销</strong>：偏向锁的分配和撤销同样依靠<code>cmpxchg</code>指令，进行原子性地更新对象头Mark Word，以记录或清除线程ID。</li>
<li><strong>状态检查</strong>：偏向锁维持期间，虽然直接关联的CPU指令不显著，但依赖硬件提供的原子读取来确认偏向状态。</li>
<li><strong>撤销机制</strong>：撤销偏向锁可能涉及额外的原子操作和内存屏障，以确保数据一致性。</li>
</ul>
<blockquote>
<p>从Java 15开始，偏向锁的默认启用被禁用，意味着JVM在启动时不会自动使用偏向锁。这一改动是因为在很多实际应用场景中，偏向锁带来的性能提升并不明显，有时甚至因为偏向锁的维护成本（如撤销偏向锁的操作）而导致性能下降。</p>
<p>如果开发者确定自己的应用程序能够从偏向锁中获益，可以通过JVM启动参数 <code>-XX:+UseBiasedLocking</code> 显式启用偏向锁。尽管如此，Oracle官方建议除非经过充分测试并明确知道偏向锁能为特定的应用场景带来性能优势，否则应让JVM默认行为保持不变，即不使用偏向锁。</p>
<p>因此，偏向锁并未废弃，只是其默认启用状态发生了变化，需要时仍可手动启用。</p>
</blockquote>
</li>
<li><p><strong>重量级锁</strong>:</p>
<ul>
<li><strong>核心机制</strong>：依赖于Linux内核提供的<strong>futex</strong>（Fast Userspace Mutex）机制来实现线程的阻塞与唤醒。当锁竞争激烈，轻量级锁膨胀为重量级锁时，通过<code>futex</code>系统调用（如<code>SYS_futex</code>）与内核交互，这可能间接触发<code>syscall</code>指令来切换到内核态处理线程状态。</li>
<li><strong>内存屏障</strong>：确保锁操作的内存可见性和正确顺序，使用如<code>mfence</code>之类的内存屏障指令。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>： 在Linux平台上，轻量级锁和偏向锁主要利用CPU级别的原子操作指令（如<code>cmpxchg</code>）来提升同步效率，减少开销，尤其是通过CAS操作。而重量级锁则借助操作系统级的futex机制来处理更复杂的线程同步问题，包括线程的阻塞与唤醒，这一过程涉及操作系统内核与用户空间的交互，间接使用到如<code>syscall</code>等指令。无论是哪种锁机制，为了确保数据一致性和操作的正确性，内存屏障的使用都是不可或缺的。</p>
</blockquote>
<ul>
<li><strong>ReentrantLock</strong></li>
</ul>
<blockquote>
<p><code>ReentrantLock</code>是Java并发包中的一个重入锁实现，它提供了与<code>synchronized</code>关键字类似的线程同步功能，但具有更高的灵活性和可控性。在HotSpot虚拟机中，<code>ReentrantLock</code>的实现（特别是公平锁与非公平锁）主要依赖以下机制和潜在的CPU指令：</p>
<ul>
<li><strong>非公平锁&#x2F;公平锁初始化</strong>:<ul>
<li>初始状态下，<code>ReentrantLock</code>通过<code>AbstractQueuedSynchronizer</code>（AQS）内部的<code>state</code>变量来追踪锁的状态，该状态的修改通常基于CAS操作，使用CPU的<code>cmpxchg</code>指令来保证原子性。</li>
</ul>
</li>
<li><strong>锁获取</strong>:<ul>
<li><strong>非公平锁</strong>：在尝试获取锁时，首先尝试通过CAS操作快速获取锁，这一步骤直接利用了CPU的原子指令。</li>
<li><strong>公平锁</strong>：会先检查是否有等待线程，然后决定是否尝试获取锁，尽管步骤更为复杂，但CAS操作依然是核心，确保了线程安全。</li>
</ul>
</li>
<li><strong>自旋与阻塞</strong>:<ul>
<li>在锁竞争激烈时，<code>ReentrantLock</code>可能会采用自旋等待策略，这期间可能会使用<code>pause</code>指令减少CPU消耗。</li>
<li>自旋失败后，未能获取锁的线程会通过<code>LockSupport.park(this)</code>方法被阻塞，背后可能涉及系统调用（如在Linux中通过futex机制）来挂起线程，间接使用到<code>syscall</code>指令。</li>
</ul>
</li>
<li><strong>锁释放</strong>:<ul>
<li>锁的释放同样依赖CAS操作来原子性地修改AQS的<code>state</code>变量，并可能唤醒等待队列中的下一个线程，这过程涉及内存屏障指令确保释放操作的可见性。</li>
</ul>
</li>
<li><strong>内存屏障</strong>:<ul>
<li>在锁的获取和释放过程中，为了确保操作的内存效应得到正确传播，JVM会插入必要的内存屏障指令，如<code>mfence</code>，来维持内存的有序访问。</li>
</ul>
</li>
</ul>
<p>综上所述，<code>ReentrantLock</code>通过高度优化的CAS操作和AQS框架，实现了灵活且高效的锁管理机制。它在非竞争和轻度竞争情况下尽量减少开销，而在高竞争场景下能有效地通过自旋、阻塞与唤醒线程来保证同步，整个过程中充分利用了现代CPU的原子指令和内存屏障特性，同时也依赖于操作系统（如Linux的futex）来实现更复杂的线程管理功能。</p>
</blockquote>
<ul>
<li><p>总结</p>
<blockquote>
<ul>
<li><strong><code>synchronized</code>关键字</strong>：<ul>
<li>在<strong>重量级锁</strong>场景下，确实高度依赖于操作系统提供的互斥量（mutex）来管理线程的阻塞与唤醒，这在Linux中可能通过<code>futex</code>系统调用实现。这背后的机制虽然不直接关联特定的CPU指令，但涉及操作系统层面的线程管理，可能间接使用到如<code>syscall</code>指令来进入内核模式处理线程状态。</li>
<li>对于<strong>轻量级锁和偏向锁</strong>，主要依赖于CPU的<strong>Compare-And-Swap (CAS)</strong> 指令，如x86架构的<code>cmpxchg</code>，来实现原子性的锁获取与释放，减少重量级锁的开销，提高并发性能。</li>
</ul>
</li>
<li>**<code>ReentrantLock</code>**：<ul>
<li>无论是在公平锁还是非公平锁的实现中，<code>ReentrantLock</code>大量依赖于<strong>CAS指令</strong>来实现锁的获取与释放，尤其是在非竞争或轻度竞争的场景下，这使得它能够提供与<code>轻量级锁</code>相似的高效性能。即使是锁的竞争变得激烈，导致线程需要被阻塞，其底层的自旋、阻塞与唤醒机制也始于尝试通过CAS操作避免进入阻塞状态，体现了对CAS指令的广泛依赖。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>synchronized</code>在不同锁状态下的实现策略反映了从轻量级的乐观锁策略（偏向锁、轻量级锁）逐渐过渡到重量级锁的悲观策略，而<code>ReentrantLock</code>则在设计上更加倾向于使用CAS指令实现的乐观锁策略，提供更多的控制选项和更高的灵活性。两者均利用了现代CPU的特性来优化性能，但具体的依赖机制根据锁的类型和竞争状况有所不同。</p>
</blockquote>
</li>
<li><p>存在的问题</p>
<ul>
<li><p>锁饥饿</p>
<ul>
<li>合理的资源分配,患寡而患不均</li>
</ul>
</li>
</ul>
</li>
<li><p>活锁</p>
<ul>
<li><p>执行顺序设定,无需相互让步</p>
</li>
<li><p><strong>引入随机等待时间</strong>：在释放锁后，让线程等待一段随机的时间再尝试获取锁，避免多个线程总是同步地抢锁和让锁。</p>
<ul>
<li><strong>设置优先级</strong>：给线程明确不同的优先级，让高优先级的线程优先获取锁，减少无序竞争。</li>
<li><strong>优化业务逻辑</strong>：仔细审查和改进业务流程，避免不合理的频繁获取和释放锁的操作模式。</li>
<li><strong>限制重试频率</strong>：对线程获取锁的重试频率进行一定的限制，防止过于频繁的尝试。</li>
<li><strong>使用更合适的同步机制</strong>：根据实际情况评估是否有更适合的同步方式来替代可能导致活锁的机制。</li>
<li><strong>增加资源缓冲</strong>：例如设置一定数量的资源缓冲池，避免线程因直接竞争同一资源而容易陷入活锁。</li>
<li><strong>监控和预警</strong>：建立监控系统，及时发现可能出现活锁的迹象并发出预警，以便及时干预和调整。</li>
<li>核心是减轻竞争,避免线程之间相互影响</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li>使用完成后直接释放之前的资源,避免资源浪费</li>
</ul>
</li>
</ul>
</li>
<li><p>线程通讯</p>
<ul>
<li>控制执行的先后顺序<ul>
<li>线程通讯之间的协调</li>
</ul>
</li>
<li>线程的优先级</li>
</ul>
</li>
</ul>
<h3 id="21-Java对锁的优化和实现"><a href="#21-Java对锁的优化和实现" class="headerlink" title="21.Java对锁的优化和实现"></a>21.Java对锁的优化和实现</h3><ul>
<li><strong>优化及实现</strong></li>
</ul>
<blockquote>
<p>在并发编程的广阔天地里，锁机制扮演着确保数据一致性和线程安全的中心角色。我们已经探讨了锁升级、锁退化，以及锁粗化和锁膨胀等关键概念，它们共同编织了一个复杂而精妙的并发控制网。为了提供一个全面且优化的视角，让我们再次整合这些概念，特别强调锁粗化与锁膨胀的内涵，以及其他重要机制：</p>
<h3 id="锁的动态调整与优化"><a href="#锁的动态调整与优化" class="headerlink" title="锁的动态调整与优化"></a>锁的动态调整与优化</h3><ul>
<li><strong>锁升级与退化</strong>：反映锁机制根据竞争程度动态调整的能力。从偏向锁或无锁状态逐步过渡到轻量级锁，乃至最终的重量级锁，以应对不断加剧的线程竞争，此为锁升级。反之，在竞争减缓时，重量级锁退回到轻量级或无锁状态，减少资源消耗，即锁退化。</li>
<li><strong>锁粗化与膨胀</strong>：<strong>锁粗化</strong>，作为优化策略，通过合并相邻且频繁被同一线程持有的细粒度锁为更广泛的锁，减少了锁操作的频次，提升了执行效率。相对地，<strong>锁膨胀</strong>是在面临高度竞争时，将原本轻量级的锁机制“膨胀”为重量级锁，以更强有力的手段管理并发访问，即使这可能伴随着更高的开销。</li>
</ul>
<h3 id="高级锁特性与策略"><a href="#高级锁特性与策略" class="headerlink" title="高级锁特性与策略"></a>高级锁特性与策略</h3><ul>
<li><strong>锁消除</strong>：一种高级优化技术，编译器或运行时环境通过深度分析确定某段代码在执行过程中无并发风险，从而直接移除不必要的加锁操作，进一步提升性能。</li>
<li><strong>读写锁</strong>：相较于传统互斥锁的独占访问，<strong>读写锁</strong>允许多线程同时读取共享资源，仅在写入时排斥所有读写访问，极大提高了读多写少场景下的并发效能。</li>
<li><strong>可重入性</strong>：<strong>可重入锁</strong>允许线程多次获取同一锁而不会引发死锁，是<code>synchronized</code>和<code>ReentrantLock</code>等机制的核心特征。</li>
<li><strong>公平与非公平锁</strong>：<strong>公平锁</strong>遵循先进先出原则，确保等待最久的线程优先获得锁；而<strong>非公平锁</strong>允许线程“插队”，牺牲一定的公平性以换取更快的响应速度。</li>
<li><strong>偏向锁的动态管理</strong>：偏向锁设计为无竞争场景优化，当遇到竞争时撤销为轻量级锁或无锁状态，而原线程后续可能重新获取时恢复偏向状态，这一过程展示了锁状态的动态适应性。</li>
<li><strong>自适应自旋</strong>：通过动态调整自旋周期，依据过去的自旋成功情况和CPU负载来决定最优自旋策略，力求平衡CPU使用效率与响应时间。</li>
</ul>
<p>这些机制共同构成了并发控制的生态系统，每一种都在特定场景下发挥着关键作用，以确保程序的高效执行与数据安全性。</p>
</blockquote>
<ul>
<li><p>总结</p>
<blockquote>
<p>确切地说，锁机制的<strong>核心实现及优化策略</strong>，诸如偏向锁、轻量级锁、重量级锁的转换，以及自旋、锁粗化与膨胀等，主要由<strong>Java虚拟机</strong>（JVM，特别是HotSpot VM）<strong>负责实现与管理</strong>。这些底层机制确保了在不同并发场景下，资源访问的高效与安全。<strong>而Java语言层面上</strong>，<strong>则通过关键字如<code>synchronized</code>、<code>volatile</code>以及<code>java.util.concurrent</code>包中的高级并发类</strong>（如<code>ReentrantLock</code>, <code>ReadWriteLock</code>, <code>Semaphore</code>等）<strong>为开发者提供了便捷的接口和抽象</strong>，使得开发者能够在不直接操作JVM底层细节的前提下，轻松实现复杂的并发控制逻辑。简言之，JVM专注于优化和实现锁的底层机制，而Java语言及标准库则专注于提供易于使用的并发编程工具和接口，二者协同工作，共同支撑起了Java平台的并发编程模型。</p>
</blockquote>
</li>
<li><p>分布式场景下的三大特性</p>
<blockquote>
<p>确实，无论是单体架构还是分布式微服务，甚至更广泛的并发编程场景，其核心问题往往归结于处理好三个基本特性：原子性、有序性、可见性。这些特性是并发控制和数据一致性的基石，无论架构如何变化，都是确保程序正确性的关键所在。</p>
<ul>
<li><strong>原子性</strong>：无论是在单线程环境下的简单操作，还是分布式系统中的事务处理，确保操作的不可分割性都是基础。在分布式系统中，通过两阶段提交、Saga事务等机制实现跨服务操作的原子性。</li>
<li><strong>有序性</strong>：无论是单机多线程间的内存模型，还是分布式系统中的消息传递顺序，控制操作的执行顺序对于正确性至关重要。分布式系统中，消息队列、分布式协调服务（如Zookeeper）帮助维持操作的全局有序执行。</li>
<li><strong>可见性</strong>：无论是在单个JVM内的线程共享数据，还是跨微服务间的数据同步，确保数据更新对所有访问者可见是避免数据不一致性的关键。分布式缓存、一致性协议（如Raft、Paxos）等技术保证数据的全局一致性或最终一致性。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="22-CPU亲和性"><a href="#22-CPU亲和性" class="headerlink" title="22.CPU亲和性"></a>22.CPU亲和性</h3><blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 设置当前线程的 CPU 亲和性，即绑定线程到特定的 CPU 核心。</span></span><br><span class="line"><span class="comment"> * 优化线程在 CPU 上的调度和执行，减少线程在不同 CPU 核心之间切换的开销，从而提高系统性能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">redisSetCpuAffinity(server.server_cpulist);</span><br></pre></td></tr></table></figure></div>

<p>在 Redis 中使用 CPU 亲和性主要有以下原因：</p>
<ol>
<li><strong>提高性能稳定性</strong>：确保 Redis 进程主要在特定的 CPU 核心上运行，减少因 CPU 核心切换导致的性能波动，使性能表现更加稳定和可预测。</li>
<li><strong>充分利用缓存</strong>：有助于保持相关数据和指令在特定 CPU 的缓存中，避免频繁在不同 CPU 间切换导致缓存失效和重新加载，提升数据访问效率。</li>
<li><strong>降低上下文切换</strong>：减少进程在不同 CPU 间迁移带来的上下文切换开销，让 Redis 能够更专注和高效地处理任务。</li>
<li><strong>优化资源分配</strong>：可以更好地规划和分配 CPU 资源，避免与其他进程竞争导致的性能下降，保障 Redis 对 CPU 资源的有效利用。</li>
</ol>
</blockquote>
<h3 id="23-多线程任务"><a href="#23-多线程任务" class="headerlink" title="23.多线程任务"></a>23.多线程任务</h3><ul>
<li>数据分片导入</li>
</ul>
<blockquote>
<p>整体思路:</p>
<p>1.数据分片,使用业务唯一字段,或组合字段作为区分依据 </p>
<ul>
<li>将数据分片后,交给线程执行</li>
<li>当出现异常时需要进行回滚操作</li>
</ul>
<p>2.出口,使用CountDownLatch作为最终汇总依据 </p>
<ul>
<li>需要对线程执行的异常情况进行兜底</li>
<li>当出现异常导致一直未归零,将之前的数据进行回滚操作</li>
</ul>
<p>3.导入成功 </p>
<p>需要注意的是,在将数据分片时,每个线程执行的任务不应具有关联性,</p>
<p>互为一个整体,避免相互影响,然后就是在异常情况下需要将原来的数据</p>
<p>进行回滚操作,保证数据的一致性和完整性</p>
<p>具体示例:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是一个简单的代码示例，展示了使用业务分片、多线程以及处理异常时回滚的基本思路：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataShardingExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARD_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟数据</span></span><br><span class="line">        <span class="type">int</span>[][] data = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SHARD_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(SHARD_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SHARD_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟处理分片数据</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;处理分片 &quot;</span> + finalI + <span class="string">&quot; 数据&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (finalI == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;模拟异常&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 记录异常</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;分片 &quot;</span> + finalI + <span class="string">&quot; 出现异常&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待所有线程完成</span></span><br><span class="line">            latch.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (latch.getCount()!= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 未归零，进行回滚操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;进行数据回滚&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据处理成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这只是一个基础示例，实际应用中还需要根据具体业务逻辑进行更完善的设计和处理。</span></span><br></pre></td></tr></table></figure></div>

<p>补充点:</p>
<ul>
<li>需要考虑数据分片的<strong>均衡性</strong>，<strong>避免某些分片任务过重或过轻</strong>。</li>
<li>对于回滚操作，需要明确具体的实现机制和范围，比如是整个事务回滚还是部分数据的特定处理。</li>
<li>异常情况的定义和分类需要更细致，不同类型的异常可能有不同的处理策略。</li>
<li>线程池的管理和配置也很重要，包括线程数量的设置、资源的合理分配等。</li>
<li>要考虑在高并发场景下的性能和稳定性，可能需要一些优化措施。</li>
<li>对数据一致性和完整性的验证机制也应该明确，如何确保回滚后数据确实达到了预期状态。</li>
</ul>
<p>总体而言，这个思路是基础和核心的，但还需要结合具体业务场景和需求进一步细化和完善。</p>
</blockquote>
<ul>
<li>CAS无锁机制<ul>
<li>仅仅保证操作的原子性,无法保证线程执行的顺序性,容易导致阻塞,cpu空转</li>
</ul>
</li>
</ul>
<h3 id="24-高并发性能"><a href="#24-高并发性能" class="headerlink" title="24.高并发性能"></a>24.高并发性能</h3><p>高并发是什么</p>
<ul>
<li>高并发是在突发的情况下,出现大量请求到达服务端,导致处理效率降低的场景</li>
</ul>
<p>如何支持高并发性能</p>
<ul>
<li><p>可以从业务,异步,缓存,堆积,负载均衡,分布式处理,资源隔离,技术优化(尽最大努力)</p>
<blockquote>
<p>锁粒度变小主要带来了以下一些好处：</p>
<p><strong>提高并发度</strong>：能让更多的线程或进程同时进行操作，而不会因为大范围的锁而相互阻塞，极大地提升了系统在高并发场景下的处理能力。</p>
<p><strong>减少锁竞争</strong>：降低了发生激烈锁竞争的概率，从而减少了因锁等待导致的性能开销。</p>
<p><strong>增强系统灵活性</strong>：可以根据具体业务需求更灵活地设置锁的范围，更好地适应不同的场景和操作模式。</p>
<p><strong>提升资源利用率</strong>：使系统资源能更充分地被利用，避免因大范围锁导致的资源闲置或浪费。</p>
<p>不过，锁粒度变小也并非全是优点，它可能会带来一定的设计和管理复杂性增加等问题哦。</p>
</blockquote>
</li>
<li><p>限流和重试上限(快速失败),请求和异常场景下的控制</p>
</li>
</ul>
<p>高并发性能带来了什么</p>
<ul>
<li>更好的用户体验:提高了用户访问系统的体验,可以感受到系统的快速响应</li>
<li>提升系统效率:充分利用系统资源,实现更高的吞吐量</li>
<li>支持业务增长:为业务规模的不断扩大提供有力支持,适应海量用户和业务量的需求</li>
<li>增加竞争力:同类产品或服务中脱颖而出,吸引更多的用户和客户</li>
<li>促进技术创新:促使开发者不断探索和采用更先进的技术来应对高并发带来的性能挑战</li>
<li>更高的商业价值:有助于提高业务收益和商业成功的可能性</li>
</ul>
<p>其它相关特性</p>
<ul>
<li><p>高性能&#x2F;高并发,高性能作为能够支撑高并发的处理的基石,侧重于初期的设计,并且需要预留高可用的设计,</p>
<p>否则一旦出现问题将会导致服务不可用</p>
</li>
<li><p>高可用,则更侧重于部署的方式</p>
</li>
</ul>
<h3 id="25-SpringBoot启动流程"><a href="#25-SpringBoot启动流程" class="headerlink" title="25.SpringBoot启动流程"></a>25.SpringBoot启动流程</h3><p>Spring Boot 的启动流程主要分为以下几个步骤：</p>
<ol>
<li><strong>主程序入口</strong>：每个 Spring Boot 程序都有一个主入口，即包含 <code>main</code> 方法的类。在 <code>main</code> 方法中调用 <code>SpringApplication.run()</code> 方法来启动整个 Spring Boot 程序。该类需要使用 <code>@SpringBootApplication</code> 注解。<ul>
<li><code>@SpringBootApplication</code> 注解是一个复合注解，它包含了 <code>@EnableAutoConfiguration</code>（根据应用所声明的依赖对 Spring 框架进行自动配置）、<code>@SpringBootConfiguration</code>（等同于 <code>@Configuration</code>，用于在 Spring 的 XML 配置文件中装配所有 bean 事务，提供一个 Spring 的上下文环境）和 <code>@ComponentScan</code>（组件扫描，可自动发现和装配 bean，默认扫描 <code>SpringApplication</code> 的 <code>run</code> 方法里的启动类所在的包路径下文件，建议将启动类放到根包路径下）这三个注解的功能。</li>
</ul>
</li>
<li><strong>创建 <code>SpringApplication</code> 对象</strong>：在调用 <code>run</code> 方法时，首先会创建一个 <code>SpringApplication</code> 实例。在其构造方法内，会调用一个初始化的 <code>initialize</code> 方法，为 <code>SpringApplication</code> 对象赋一些初值。</li>
<li><strong>关键步骤执行</strong>：<ul>
<li>创建应用的监听器 <code>SpringApplicationRunListeners</code> 并开始监听。</li>
<li>加载 Spring Boot 配置环境（<code>ConfigurableEnvironment</code>），如果是通过 Web 容器发布，会加载 <code>StandardEnvironment</code>（最终也继承了 <code>ConfigurableEnvironment</code>）。通过 <code>Environment</code> 对象可以获取配置文件中指定 key 对应的 value，其内部调用了 <code>PropertyResolver</code> 接口的 <code>getProperty</code> 方法。</li>
<li>将配置环境加入到监听器对象中。</li>
<li>创建 <code>run</code> 方法的返回对象：<code>ConfigurableApplicationContext</code>（应用配置上下文）。方法会先获取显式设置的应用上下文，如果不存在，再加载默认的环境配置（通过判断是否是 Web 环境），默认选择 <code>AnnotationConfigApplicationContext</code> 注解上下文（通过扫描所有注解类来加载 bean），最后通过 <code>BeanUtils</code> 实例化上下文对象并返回。</li>
</ul>
</li>
<li><strong>刷新上下文</strong>（refresh context）：这是启动流程中的关键步骤，主要包括以下子步骤（详细步骤可参考<a class="link"   href="https://juejin.cn/post/6999540250087260197" >SpringBoot 源码之容器刷新 RefreshContext 方法详解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）：<ul>
<li><code>prepareRefresh</code>：进行刷新前的准备工作，如记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符等。</li>
<li><code>obtainFreshBeanFactory</code>：获取 <code>BeanFactory</code>（实际调用的是 <code>GenericApplicationContext</code> 的 <code>refreshBeanFactory</code> 方法），并设置其序列化 ID，用于加载 bean 定义、注册 bean 等。</li>
<li><code>prepareBeanFactory</code>：设置 beanFactory 的参数（如类加载器、表达式解析器等）；添加一些组件到 beanFactory 中（如属性编辑注册器、后置处理器等）；忽略某些接口的自动装配功能；注册依赖；向 beanFactory 中注册环境相关的 bean。</li>
<li><code>postProcessBeanFactory</code>：在标准初始化之后，修改应用容器的内部 beanFactory，此时所有 bean 定义已加载，但尚未实例化任何 bean，允许在此处注册特殊的 bean 后置处理器。</li>
<li><code>invokeBeanFactoryPostProcessors</code>：实例化并调用所有已注册的 <code>BeanFactoryPostProcessor</code>。首先获取当前应用上下文 <code>BeanFactoryPostProcessors</code> 变量中的值，然后分别获取实现了 <code>BeanDefinitionRegistryPostProcessor</code> 接口的对象，调用其 <code>postProcessBeanDefinitionRegistry</code> 方法，再获取普通的 <code>BeanFactoryPostProcessor</code> 的 bean 名称，最后遍历不同类型的后置处理器并调用其 <code>postProcessBeanFactory</code> 方法。</li>
<li><code>registerBeanPostProcessors</code>：遍历实现了 <code>BeanFactoryProcessor</code> 的处理器，将其添加到相应的处理器列表中，并调用 <code>registerBeanPostProcessors</code> 方法，将处理器添加到 <code>BeanFactory</code> 中。</li>
<li><code>initMessageSource</code>：给相关参数赋值。</li>
<li><code>registerListeners</code>：注册监听事件，使用事件广播器发布早期应用程序事件到相应的监听器。</li>
<li><code>finishRefresh</code>：初始化上下文的生命周期处理器，将刷新完毕事件传播到生命周期处理器，并推送上下文刷新完毕事件到相应的监听器。</li>
</ul>
</li>
<li><strong>执行刷新容器后的后置处理逻辑</strong>（在 Spring Boot 中为空方法）。</li>
<li><strong>调用 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code></strong> 的 <code>run</code> 方法，可实现这两个接口，以便在 Spring 容器启动后执行一些加载业务数据等操作。</li>
<li><strong>报告启动异常</strong>（若启动过程中抛出异常）。</li>
<li><strong>最终返回容器对象</strong>。</li>
</ol>
<p>整个启动流程涉及到众多的细节和复杂的逻辑，包括环境准备、bean 的加载与注册、后置处理器的调用、事件的发布等，通过这些步骤实现了 Spring Boot 应用的自动配置和启动。具体的实现细节可以深入研究 Spring Boot 的源代码来进一步了解。</p>
<p><strong>总结</strong></p>
<p>SpringBoot的工作流程分为实例创建、环境构建、组件注册、容器刷新以及应用启动这几个阶段<br><strong>前两个阶段</strong>属于SpringBoot相关,包含了以下核心工作, 如SpringApplicationContext,配置类&#x2F;配置文件,事件监听器,Web环境确认等初始化工作<br><strong>后两个阶段</strong>则是和Spring相关,完成了组件注册,容器刷新工作,是对之前阶段工作的补充<br><strong>最后应用启动</strong>则是SpringBoot完成,并且预留了扩展点</p>
<blockquote>
<p><strong>实例化阶段</strong>：<br>创建 <code>SpringApplication</code> 对象，为后续的启动流程做准备。此阶段还会对一些初始属性和配置进行设置。</p>
<p><strong>构建环境阶段</strong>：</p>
<ul>
<li>创建应用的监听器 <code>SpringApplicationRunListeners</code> 并开始监听，以便在后续流程中响应关键事件。</li>
<li>加载适合应用运行环境（如是否为 Web 环境）的配置信息，例如从配置文件中读取属性，确定应用的基本设置。</li>
</ul>
<p><strong>注册组件阶段</strong>：<br>将各种组件、Bean 定义等注册到相应的容器中，为后续的实例化和管理做准备。</p>
<p><strong>刷新容器阶段</strong>：</p>
<ul>
<li>进行一系列深度处理，如创建 <code>BeanFactory</code>，用于加载和管理 Bean 定义。</li>
<li>处理后置处理器，包括 <code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 等，对 Bean 的定义和创建过程进行干预和扩展。</li>
<li>初始化消息源，以便处理应用中的国际化和消息相关的功能。</li>
<li>注册监听器，用于接收和处理应用中的各种事件。</li>
</ul>
<p><strong>启动阶段</strong>：</p>
<ul>
<li>执行 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 的 <code>run</code> 方法，可在此阶段进行一些自定义的启动逻辑和任务。</li>
<li>处理可能出现的启动异常，确保应用能够正常启动或者给出明确的错误提示。</li>
<li>最终完成应用的启动，使其处于可运行状态，准备接收请求和处理业务逻辑。</li>
</ul>
</blockquote>
<h3 id="26Spring的ignoreDependencyType-Interface影响范围"><a href="#26Spring的ignoreDependencyType-Interface影响范围" class="headerlink" title="26Spring的ignoreDependencyType&#x2F;Interface影响范围"></a>26Spring的<strong>ignoreDependencyType&#x2F;Interface影响范围</strong></h3><ol>
<li>ignoreDependency相关方法,仅仅只影响xml配置的自动装配,不会影响到注解场景的自动装配</li>
<li>主要是为了避免重复加载带来的影响,所以干脆忽略xml配置的自动装配信息</li>
<li>如果一个 bean 的某个属性通过 <code>&lt;property&gt;</code> 标签设置了值，并且同时存在自动装配的配置（如 <code>default-autowire</code> 或 <code>@Autowired</code>），那么 Spring 会优先使用 <code>&lt;property&gt;</code> 中设置的值来赋值给该属性，因为其优先级高于自动装配，相当于显示赋值，所以忽略方法不对其生效</li>
</ol>
<h3 id="27-SpringBoot生命周期发布事件"><a href="#27-SpringBoot生命周期发布事件" class="headerlink" title="27.SpringBoot生命周期发布事件"></a>27.SpringBoot生命周期发布事件</h3><p><strong>Spring Boot 中 <code>springApplication</code> 的生命周期事件一共有七个，它们发生的顺序如下：</strong></p>
<ol>
<li><code>ApplicationStartingEvent</code>：在一个 <code>SpringApplication</code> 对象的初始化和监听器的注册之后发布。</li>
<li><code>ApplicationEnvironmentPreparedEvent</code>：在 <code>environment</code> 对象创建之后，<code>context</code> 对象创建之前发布。</li>
<li><code>ApplicationContextInitializedEvent</code>：在 <code>ApplicationContext</code> 对象被初始化后发布，此时所有 bean 的定义还没被加载。</li>
<li><code>ApplicationPreparedEvent</code>：在 bean 定义被加载之后，<code>context</code> 对象刷新之前发布。</li>
<li><code>ApplicationStartedEvent</code>：在 <code>context</code> 对象刷新之后，应用启动器被调用之前发布。</li>
<li><code>ApplicationReadyEvent</code>：在应用启动器被调用之后发布，代表着应用已正常启动，可以接收请求了。</li>
<li><code>ApplicationFailedEvent</code>：只有在应用启动出现异常，无法正常启动时才会发布。</li>
</ol>
<h3 id="28-SpringBoot相关特性"><a href="#28-SpringBoot相关特性" class="headerlink" title="28.SpringBoot相关特性"></a>28.SpringBoot相关特性</h3><p>在 Spring 框架中，Initializer 用于早期初始化，Event 表示特定操作或状态变化，Listener 监听特定 Event 并执行处理逻辑。</p>
<p>关系为：关键操作触发 Event 发布，Initializer 参与早期初始化，Listener 注册监听并在对应 Event 发生时执行处理逻辑，实现解耦和灵活交互。</p>
<p>以下是对应的代码示例：</p>
<p><strong>Initializer 示例</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextInitializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomInitializer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行初始化操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>Event 示例</strong>：自定义事件</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>Listener 示例</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ApplicationContextEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;CustomEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(CustomEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理事件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理自定义事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="29-SpringBoot实现发布与监听"><a href="#29-SpringBoot实现发布与监听" class="headerlink" title="29.SpringBoot实现发布与监听"></a>29.SpringBoot实现发布与监听</h3><p><strong>Spring Boot 基于 Spring 的事件机制，实现事件发布和监听的步骤如下：</strong></p>
<p><strong>定义自定义事件</strong>：创建一个继承自<code>ApplicationEvent</code>的类。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomEvent</span><span class="params">(Object source, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>定义事件监听器</strong>：</p>
<ul>
<li>方式一：实现<code>ApplicationListener</code>接口并指定监听事件类型。</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;CustomEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(CustomEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>方式二：使用<code>@EventListener</code>注解的方法。</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(CustomEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>发布事件</strong>：注入<code>ApplicationContext</code>，调用<code>publishEvent</code>方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="built_in">this</span>, <span class="string">&quot;message&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Spring Boot 启动过程中会发布一些内置事件，可通过相应监听器监听并处理。还可通过多种方式注册监听器，具体根据项目需求选择。事件机制提高了系统灵活性和可扩展性，但要注意处理耗时问题。</p>
<p><strong>SpringBoot怎么知道要调用哪个监听器</strong></p>
<p>Spring Boot 能够知道调用哪个类型的事件监听器，是因为事件监听器在注册时指定了要监听的事件类型。</p>
<p>在 Spring 框架中，事件监听器需要实现<code>ApplicationListener</code>接口，并指定其泛型参数为要监听的事件类型。例如，如果有一个自定义事件<code>CustomEvent</code>，那么对应的事件监听器可以这样定义：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;CustomEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(CustomEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 CustomEvent 事件的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样，当 Spring 容器中发布了<code>CustomEvent</code>类型的事件时，Spring 就会自动调用<code>CustomEventListener</code>中的<code>onApplicationEvent</code>方法来处理该事件。</p>
<p>另外，也可以使用<code>@EventListener</code>注解来简化事件监听器的定义。在方法上添加<code>@EventListener</code>注解，并指定要监听的事件类型作为参数，同时该类需要纳入到 Spring 容器中管理，例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener(CustomEvent.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCustomEvent</span><span class="params">(CustomEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 CustomEvent 事件的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 Spring Boot 启动时，会扫描并注册所有符合条件的事件监听器。当发布事件时，Spring 会根据事件的类型，找到对应的监听器并执行其相应的处理方法。</p>
<p>Spring Boot 中事件监听器的注册和匹配过程是由 Spring 框架的核心机制自动管理的。通过这种方式，实现了事件发布者和事件监听器之间的解耦，使得系统更加灵活和可扩展。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>ApplicationEvent定义事件发布逻辑</p>
</li>
<li><p>ApplicationListener定义事件监听之后的业务逻辑</p>
</li>
<li><p>上述都是抽象,具体实现看你自己,调用监听器逻辑由Spring底层实现</p>
</li>
<li><p>Nacos中也是定义了类似的逻辑,抽象为EventListenr和EventPublisher,只不过使用范围有区别<br>Spring相关时间机制用于应用启动后的一些事件.也就是内部的事件机制,<br>而Nacos这套则用于跨客户端&#x2F;服务端的事件(服务间的事件),比如,也就是是外部的事件机制,</p>
<blockquote>
<p><strong>二者区别</strong><br>在 Nacos 中，同时运用 Spring 的事件机制和自身的事件机制。<br>Spring 的事件机制用于与 Spring 环境的集成和交互，如在 Spring Cloud 中完成服务注册。</p>
<p>例如，Web 服务器初始化完成触发事件后，Nacos 相关类会监听并进行服务注册。<br>Nacos 自身的事件机制处理内部的各种事件，像心跳状态变化、服务状态变化等。</p>
<p>最终Nacos通过SpringBoot的机制完成服务&#x2F;客户端的实例化,以及自己的机制完成了分布式场景中的数据同步,如心跳,健康机制,服务变动,服务实例数据同步</p>
<p>两者区别在于使用场景和目的：</p>
<ul>
<li>Spring 事件机制侧重在 Spring 环境中的通用事件处理和集成，实现组件解耦。</li>
<li>Nacos 自身事件机制专为处理内部特定功能和业务逻辑相关事件，确保系统内部通信和协作。</li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
</search>
